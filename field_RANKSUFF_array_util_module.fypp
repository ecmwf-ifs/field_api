!Copyright 2023 Meteo-France, ECMWF 
!
!Licensed under the Apache License, Version 2.0 (the "License");
!you may not use this file except in compliance with the License.
!You may obtain a copy of the License at
!
!    http://www.apache.org/licenses/LICENSE-2.0
!
!    Unless required by applicable law or agreed to in writing, software
!    distributed under the License is distributed on an "AS IS" BASIS,
!    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!    See the License for the specific language governing permissions and
!    limitations under the License.

MODULE FIELD_${RANK}$${SUFF}$_ARRAY_UTIL_MODULE

#:set fieldTypeList = fieldType.getFieldTypeList (ranks=[RANK], kinds=['JP' + SUFF])

USE FIELD_ARRAY_MODULE
${fieldType.useParkind1 ()}$

IMPLICIT NONE

#:for method in ['LOAD', 'SAVE', 'COPY', 'WIPE', 'HOST']
INTERFACE ${method}$
#:for ft in fieldTypeList
  MODULE PROCEDURE ${method}$_${ft.name}$_ARRAY
#:endfor
END INTERFACE

#:endfor

CONTAINS

#:for ft in fieldTypeList
SUBROUTINE LOAD_${ft.name}$_ARRAY (KLUN, YD)

USE FIELD_UTIL_MODULE, ONLY : LOAD

INTEGER (KIND=JPIM), INTENT (IN) :: KLUN
TYPE (${ft.name}$_ARRAY) :: YD

IF (ASSOCIATED (YD%F_P)) THEN
  CALL LOAD (KLUN, YD%F_P)
ENDIF

END SUBROUTINE

SUBROUTINE SAVE_${ft.name}$_ARRAY (KLUN, YD)

USE FIELD_UTIL_MODULE, ONLY : SAVE

INTEGER (KIND=JPIM), INTENT (IN) :: KLUN
TYPE (${ft.name}$_ARRAY) :: YD
END SUBROUTINE

SUBROUTINE COPY_${ft.name}$_ARRAY (SELF, LDCREATED, LDFIELDAPI)

USE FIELD_UTIL_MODULE, ONLY : COPY

TYPE (${ft.name}$_ARRAY) :: SELF
LOGICAL, INTENT (IN), OPTIONAL :: LDCREATED, LDFIELDAPI
LOGICAL :: LLFIELDAPI, LLCREATED

LLFIELDAPI = .FALSE.
IF (PRESENT (LDFIELDAPI)) LLFIELDAPI = LDFIELDAPI

LLCREATED = .FALSE.
IF (PRESENT (LDCREATED)) LLCREATED = LDCREATED

IF (.NOT. LLCREATED) THEN
  !$acc enter data create (SELF)
  !$acc update device (SELF)
ENDIF

!$acc serial present (SELF)
NULLIFY (SELF%P)
NULLIFY (SELF%F_P)
!$acc end serial

IF (LLFIELDAPI .AND. ASSOCIATED (SELF%F_P)) THEN
  CALL COPY (SELF%F_P, LDCREATED)
ENDIF

END SUBROUTINE 

SUBROUTINE WIPE_${ft.name}$_ARRAY (SELF, LDDELETED, LDFIELDAPI)

USE FIELD_UTIL_MODULE, ONLY : WIPE

TYPE (${ft.name}$_ARRAY) :: SELF
LOGICAL, INTENT (IN), OPTIONAL :: LDDELETED, LDFIELDAPI
LOGICAL :: LLFIELDAPI, LLDELETED

LLFIELDAPI = .FALSE.
IF (PRESENT (LDFIELDAPI)) LLFIELDAPI = LDFIELDAPI

LLDELETED = .FALSE.
IF (PRESENT (LDDELETED)) LLDELETED = LDDELETED

IF (LLFIELDAPI .AND. ASSOCIATED (SELF%F_P)) THEN
  CALL WIPE (SELF%F_P, LDDELETED)
ENDIF

IF (.NOT. LLDELETED) THEN
  !$acc exit data delete (SELF)
ENDIF

END SUBROUTINE 

SUBROUTINE HOST_${ft.name}$_ARRAY (SELF)

USE FIELD_UTIL_MODULE, ONLY : HOST

TYPE (${ft.name}$_ARRAY) :: SELF

IF (ASSOCIATED (SELF%F_P)) THEN
  CALL HOST (SELF%F_P)
ENDIF

END SUBROUTINE 

#:endfor

END MODULE
