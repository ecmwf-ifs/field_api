! (C) Copyright 2022- ECMWF.
! (C) Copyright 2022- Meteo-France.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

PROGRAM TEST_GANG

USE FIELD_MODULE
USE FIELD_FACTORY_MODULE
USE FIELD_ACCESS_MODULE
USE PARKIND1
USE OMP_LIB, ONLY: OMP_GET_MAX_THREADS
IMPLICIT NONE

CLASS(FIELD_4RD), POINTER :: YLF4
TYPE(FIELD_3RD_PTR), ALLOCATABLE :: YLF3L (:)

INTEGER (KIND=JPIM), PARAMETER :: NPROMA = 32, NFLEVG = 15, NDIM = 3, NGPBLKS = 10
LOGICAL, PARAMETER :: LLPERSISTENT = .TRUE.

INTEGER (KIND=JPIM), PARAMETER :: ILB (4) = [1,0,1,1], IUB (4) = [NPROMA, NFLEVG, NDIM, NGPBLKS]

#include "abor1.intfb.h"

INTEGER (KIND=JPIM) :: JDIM
INTEGER (KIND=JPIM) :: ISTEP
LOGICAL, PARAMETER :: LLVERBOSE = .TRUE.

REAL (KIND=JPRD) :: ZCOEF (NDIM)
!$acc declare create (ZCOEF)

DO JDIM = 1, NDIM
  ZCOEF (JDIM) = REAL (JDIM, JPRD)
ENDDO

YLF4 => NULL ()

CALL NEW_YLF4
CALL SET_VIEW_YLF4

DO ISTEP = 1, 100
  CALL RUN
ENDDO

CALL DEL_YLF4

CONTAINS

INTEGER (KIND=JPIM) FUNCTION IRAND (K1, K2)

INTEGER (KIND=JPIM) :: K1, K2

INTEGER*8, SAVE :: X = 2713

X = MODULO (16807_8 * X, 2147483647_8)

IRAND = K1 + MODULO (X, INT (K2-K1+1, 8))

END FUNCTION

SUBROUTINE SORTR8 (KDIM, KORD, PVAL)

INTEGER (KIND=JPIM) :: KDIM
INTEGER (KIND=JPIM) :: KORD (KDIM)
REAL (KIND=JPRD)    :: PVAL (KDIM)

INTEGER (KIND=JPIM) :: I, J, ITMP

DO I = 1, KDIM
  DO J = I+1, KDIM
    IF (PVAL (KORD (I)) > PVAL (KORD (J))) THEN
      ITMP = KORD (I)
      KORD (I) = KORD (J)
      KORD (J) = ITMP
    ENDIF
  ENDDO
ENDDO

END SUBROUTINE

SUBROUTINE RUN

INTEGER (KIND=JPIM) :: IFLD (NDIM)
INTEGER (KIND=JPIM) :: ICASE, ISIZE
INTEGER (KIND=JPIM) :: JFLD, JDIM, ITMP

REAL (KIND=JPRD) :: ZVAL (NDIM)

ISIZE = IRAND (1, NDIM)

DO JFLD = 1, NDIM
  IFLD (JFLD) = JFLD
  ZVAL (JFLD) = REAL (IRAND (0, 100000), JPRD) / REAL (100000, JPRD)
ENDDO


CALL SORTR8 (NDIM, IFLD, ZVAL)

IF (.NOT. ASSOCIATED (YLF4)) THEN

  CALL NEW_YLF4
  
  SELECT CASE (IRAND (1, 6))
    CASE (1)
      CALL SET_VIEW_YLF4
    CASE (2)
      CALL SET_DEVICE_YLF4
    CASE (3)
      CALL SET_HOST_YLF4
    CASE (4)
      CALL SET_VIEW_YLF3 ([(JFLD, JFLD = 1, NDIM)])
    CASE (5)
      CALL SET_DEVICE_YLF3 ([(JFLD, JFLD = 1, NDIM)])
    CASE (6)
      CALL SET_HOST_YLF3 ([(JFLD, JFLD = 1, NDIM)])
    CASE DEFAULT
      CALL ABOR1 ('UNEXPECTED CASE')
  END SELECT
  
ELSE

  SELECT CASE (IRAND (1, 122))
    CASE (1:10)
      CALL UPDATE_COEF
      CALL SET_VIEW_YLF4
    CASE (11:20)
      CALL GET_VIEW_YLF4
    CASE (21:30)
      CALL UPDATE_COEF (IFLD (1:ISIZE))
      CALL SET_VIEW_YLF3 (IFLD (1:ISIZE))
    CASE (31:40)
      CALL GET_VIEW_YLF3 (IFLD (1:ISIZE))
    CASE (41:50)
      CALL UPDATE_COEF
      CALL SET_HOST_YLF4
    CASE (51:60)
      CALL UPDATE_COEF
      CALL SET_DEVICE_YLF4
    CASE (61:70)
      CALL GET_HOST_YLF4
    CASE (71:80)
      CALL GET_DEVICE_YLF4
    CASE (81:90)
      CALL UPDATE_COEF (IFLD (1:ISIZE))
      CALL SET_HOST_YLF3 (IFLD (1:ISIZE))
    CASE (91:100)
      CALL UPDATE_COEF (IFLD (1:ISIZE))
      CALL SET_DEVICE_YLF3 (IFLD (1:ISIZE))
    CASE (101:110)
      CALL GET_DEVICE_YLF3 (IFLD (1:ISIZE))
    CASE (111:120)
      CALL GET_HOST_YLF3 (IFLD (1:ISIZE))
    CASE (121:122)
      CALL DEL_YLF4
    CASE DEFAULT
      CALL ABOR1 ('UNEXPECTED CASE')
  END SELECT 

ENDIF

END SUBROUTINE

SUBROUTINE UPDATE_COEF (KFLD)

INTEGER (KIND=JPIM), OPTIONAL, INTENT (IN) :: KFLD (:)

INTEGER (KIND=JPIM) :: JDIM, JFLD

IF (PRESENT (KFLD)) THEN

  CALL PLOG ("UPDATE_COEF", KFLD)

  DO JDIM = 1, SIZE (KFLD)
    JFLD = KFLD (JDIM)
    ZCOEF (JFLD) = REAL (JFLD, JPRD) * REAL (IRAND (0, 999), JPRD) / 1000._JPRD
  ENDDO

ELSE

  CALL PLOG ("UPDATE_COEF")

  DO JFLD = 1, NDIM
    ZCOEF (JFLD) = REAL (JFLD, JPRD) * REAL (IRAND (0, 999), JPRD) / 1000._JPRD
  ENDDO

ENDIF

END SUBROUTINE

REAL (KIND=JPRD) FUNCTION FUNC (JLON_, JLEV_, JFLD_, JBLK_, PCOEF_)

!$acc routine (FUNC) seq

INTEGER (KIND=JPIM) :: JLON_, JLEV_, JFLD_, JBLK_
REAL (KIND=JPRD) :: PCOEF_ (NDIM)

FUNC = REAL (JLON_, JPRD) + 100._JPRD * (REAL (JLEV_, JPRD) + 100._JPRD * &
    & (PCOEF_ (JFLD_) + 100._JPRD * (REAL (JBLK_, JPRD))))

END FUNCTION

SUBROUTINE NEW_YLF4

CALL PLOG ("NEW_YLF4")

CALL FIELD_NEW (YLF4, CHILDREN=YLF3L, UBOUNDS=IUB, LBOUNDS=ILB, PERSISTENT=LLPERSISTENT)

CALL CHECK_STATUS

END SUBROUTINE

SUBROUTINE SET_VIEW_YLF4

INTEGER (KIND=JPIM) :: JLON, JLEV, JFLD, JBLK
REAL (KIND=JPRD), POINTER :: ZPTR3 (:,:,:)

CALL PLOG ("SET_VIEW_YLF4")

CALL YLF4%SYNC_HOST_RDWR ()

!$OMP PARALLEL DO PRIVATE (ZPTR3, JBLK)
DO JBLK = 1, NGPBLKS
  ZPTR3 => YLF4%GET_VIEW (BLOCK_INDEX=JBLK)
  DO JFLD = 1, NDIM
    DO JLEV = 0, NFLEVG
      DO JLON = 1, NPROMA
        ZPTR3 (JLON, JLEV, JFLD) = FUNC (JLON, JLEV, JFLD, JBLK, ZCOEF)
      ENDDO
    ENDDO
  ENDDO
ENDDO
!$OMP END PARALLEL DO

END SUBROUTINE

SUBROUTINE GET_VIEW_YLF4

INTEGER (KIND=JPIM) :: JLON, JLEV, JFLD, JBLK
REAL (KIND=JPRD), POINTER :: ZPTR3 (:,:,:)

CALL PLOG ("GET_VIEW_YLF4")

CALL YLF4%SYNC_HOST_RDWR ()

!$OMP PARALLEL DO PRIVATE (ZPTR3, JBLK)
DO JBLK = 1, NGPBLKS
  ZPTR3 => YLF4%GET_VIEW (BLOCK_INDEX=JBLK)
  DO JFLD = 1, NDIM
   DO JLEV = 0, NFLEVG
     DO JLON = 1, NPROMA
       IF (ZPTR3 (JLON, JLEV, JFLD) /= FUNC (JLON, JLEV, JFLD, JBLK, ZCOEF)) THEN
         PRINT *, ZPTR3 (JLON, JLEV, JFLD)
         PRINT *, FUNC (JLON, JLEV, JFLD, JBLK, ZCOEF)
         CALL ABOR1 ('GET_VIEW_YLF4: VALUE MISMATCH')
       ENDIF
     ENDDO
   ENDDO
  ENDDO
ENDDO
!$OMP END PARALLEL DO

END SUBROUTINE

SUBROUTINE SET_VIEW_YLF3 (KFLD)

INTEGER (KIND=JPIM), INTENT (IN) :: KFLD (:)

INTEGER (KIND=JPIM) :: JLON, JLEV, JFLD, JBLK, JDIM
REAL (KIND=JPRD), POINTER :: ZPTR2 (:,:)

CALL PLOG ("SET_VIEW_YLF3", KFLD)

DO JDIM = 1, SIZE (KFLD)
  JFLD = KFLD (JDIM)
  CALL YLF3L(JFLD)%PTR%SYNC_HOST_RDWR ()
ENDDO

!$OMP PARALLEL DO PRIVATE (ZPTR2, JBLK, JFLD)
DO JBLK = 1, NGPBLKS
  DO JDIM = 1, SIZE (KFLD)
    JFLD = KFLD (JDIM)
    ZPTR2 => YLF3L(JFLD)%PTR%GET_VIEW (BLOCK_INDEX=JBLK)
    DO JLEV = 0, NFLEVG
      DO JLON = 1, NPROMA
        ZPTR2 (JLON, JLEV) = FUNC (JLON, JLEV, JFLD, JBLK, ZCOEF)
      ENDDO
    ENDDO
  ENDDO
ENDDO
!$OMP END PARALLEL DO

END SUBROUTINE

SUBROUTINE GET_VIEW_YLF3 (KFLD)

INTEGER (KIND=JPIM), INTENT (IN) :: KFLD (:)

INTEGER (KIND=JPIM) :: JLON, JLEV, JFLD, JBLK, JDIM
REAL (KIND=JPRD), POINTER :: ZPTR2 (:,:)

CALL PLOG ("GET_VIEW_YLF3", KFLD)

DO JDIM = 1, SIZE (KFLD)
  JFLD = KFLD (JDIM)
  CALL YLF3L(JFLD)%PTR%SYNC_HOST_RDWR ()
ENDDO

!$OMP PARALLEL DO PRIVATE (ZPTR2, JBLK, JFLD)
DO JBLK = 1, NGPBLKS
  DO JDIM = 1, SIZE (KFLD)
    JFLD = KFLD (JDIM)
    ZPTR2 => YLF3L(JFLD)%PTR%GET_VIEW (BLOCK_INDEX=JBLK)
    DO JLEV = 0, NFLEVG
      DO JLON = 1, NPROMA
        IF (ZPTR2 (JLON, JLEV) /= FUNC (JLON, JLEV, JFLD, JBLK, ZCOEF)) THEN
          PRINT *, ZPTR2 (JLON, JLEV)
          PRINT *, FUNC (JLON, JLEV, JFLD, JBLK, ZCOEF)
          CALL ABOR1 ('GET_VIEW_YLF4: VALUE MISMATCH')
        ENDIF
      ENDDO
    ENDDO
  ENDDO
ENDDO
!$OMP END PARALLEL DO

END SUBROUTINE

SUBROUTINE SET_HOST_YLF4

REAL (KIND=JPRD), POINTER :: ZHOST4 (:,:,:,:)
INTEGER (KIND=JPIM) :: JBLK, JLEV, JLON, JFLD

CALL PLOG ("SET_HOST_YLF4")

ZHOST4 => GET_HOST_DATA_RDWR (YLF4)

CALL CHECK_STATUS

DO JBLK = 1, NGPBLKS
  DO JFLD = 1, NDIM
    DO JLEV = 0, NFLEVG
      DO JLON = 1, NPROMA
        ZHOST4 (JLON, JLEV, JFLD, JBLK) = FUNC (JLON, JLEV, JFLD, JBLK, ZCOEF)
      ENDDO
    ENDDO
  ENDDO
ENDDO

CALL CHECK_STATUS

END SUBROUTINE

SUBROUTINE SET_DEVICE_YLF4

REAL (KIND=JPRD), POINTER :: ZDEVICE4 (:,:,:,:)
INTEGER (KIND=JPIM) :: JBLK, JLEV, JLON, JFLD

CALL PLOG ("SET_DEVICE_YLF4")

ZDEVICE4 => GET_DEVICE_DATA_RDWR (YLF4)

CALL CHECK_STATUS


!$acc update device (ZCOEF)

!$acc serial present (ZDEVICE4) 
DO JBLK = 1, NGPBLKS
  DO JFLD = 1, NDIM
    DO JLEV = 0, NFLEVG
      DO JLON = 1, NPROMA
        ZDEVICE4 (JLON, JLEV, JFLD, JBLK) = FUNC (JLON, JLEV, JFLD, JBLK, ZCOEF)
      ENDDO
    ENDDO
  ENDDO
ENDDO
!$acc end serial


CALL CHECK_STATUS

END SUBROUTINE

SUBROUTINE DEL_YLF4

CALL PLOG ("DEL_YLF4")

DEALLOCATE (YLF3L)
CALL FIELD_DELETE (YLF4)
YLF4 => NULL ()

END SUBROUTINE

SUBROUTINE GET_HOST_YLF4

REAL (KIND=JPRD), POINTER :: ZHOST4 (:,:,:,:)

INTEGER (KIND=JPIM) :: JBLK, JLEV, JLON, JFLD

CALL PLOG ("GET_HOST_YLF4")

IF (SIZE (YLF3L) /= NDIM) CALL ABOR1 ('SIZE MISMATCH')

ZHOST4 => GET_HOST_DATA_RDONLY (YLF4)

CALL CHECK_DIMS_YLF4 (ZHOST4)

DO JBLK = 1, NGPBLKS
  DO JFLD = 1, NDIM
    DO JLEV = 0, NFLEVG
      DO JLON = 1, NPROMA
        IF (ZHOST4 (JLON, JLEV, JFLD, JBLK) /= FUNC (JLON, JLEV, JFLD, JBLK, ZCOEF)) THEN
          PRINT *, ZHOST4 (JLON, JLEV, JFLD, JBLK)
          PRINT *,  FUNC (JLON, JLEV, JFLD, JBLK, ZCOEF)
          CALL ABOR1 ('GET_HOST_YLF4: VALUE MISMATCH')
        ENDIF
      ENDDO
    ENDDO
  ENDDO
ENDDO

CALL CHECK_STATUS

END SUBROUTINE

SUBROUTINE GET_DEVICE_YLF4

REAL (KIND=JPRD), POINTER :: ZDEVICE4 (:,:,:,:)

INTEGER (KIND=JPIM) :: JBLK, JLEV, JLON, JFLD

CALL PLOG ("GET_DEVICE_YLF4")

IF (SIZE (YLF3L) /= NDIM) CALL ABOR1 ('SIZE MISMATCH')

ZDEVICE4 => GET_DEVICE_DATA_RDONLY (YLF4)

CALL CHECK_DIMS_YLF4 (ZDEVICE4)

!$acc update device (ZCOEF)

!$acc serial present (ZDEVICE4) 

DO JBLK = 1, NGPBLKS
  DO JFLD = 1, NDIM
    DO JLEV = 0, NFLEVG
      DO JLON = 1, NPROMA
        IF (ZDEVICE4 (JLON, JLEV, JFLD, JBLK) /= FUNC (JLON, JLEV, JFLD, JBLK, ZCOEF)) THEN
          PRINT *, JLON, JLEV, JFLD, JBLK
          PRINT *, ZDEVICE4 (JLON, JLEV, JFLD, JBLK)
          PRINT *,  FUNC (JLON, JLEV, JFLD, JBLK, ZCOEF)
          CALL ABOR1 ('VALUE MISMATCH')
        ENDIF
      ENDDO
    ENDDO
  ENDDO
ENDDO

!$acc end serial

CALL CHECK_STATUS

END SUBROUTINE

SUBROUTINE CHECK_DIMS_YLF4 (P4)

INTEGER (KIND=JPIM) :: JDIM

REAL (KIND=JPRD), POINTER :: P4 (:,:,:,:)

DO JDIM = 1, 4
  IF (LBOUND (P4, JDIM) /= ILB (JDIM)) THEN
    PRINT *, LBOUND (P4) 
    PRINT *, ILB 
    CALL ABOR1 ('LBOUND MISMATCH')
  ENDIF
  IF (UBOUND (P4, JDIM) /= IUB (JDIM)) THEN
    PRINT *, UBOUND (P4)  
    PRINT *, IUB 
    CALL ABOR1 ('UBOUND MISMATCH')
  ENDIF
ENDDO

END SUBROUTINE

SUBROUTINE CHECK_DIMS_YLF3 (P3)

INTEGER (KIND=JPIM) :: JDIM

REAL (KIND=JPRD), POINTER :: P3 (:,:,:)

DO JDIM = 1, 2
  IF (LBOUND (P3, JDIM) /= ILB (JDIM)) CALL ABOR1 ('LBOUND MISMATCH')
  IF (UBOUND (P3, JDIM) /= IUB (JDIM)) CALL ABOR1 ('UBOUND MISMATCH')
ENDDO

IF (LBOUND (P3, 3) /= ILB (4)) CALL ABOR1 ('LBOUND MISMATCH')
IF (UBOUND (P3, 3) /= IUB (4)) CALL ABOR1 ('UBOUND MISMATCH')

END SUBROUTINE

SUBROUTINE SET_HOST_YLF3 (KFLD)

INTEGER (KIND=JPIM), INTENT (IN) :: KFLD (:)

REAL (KIND=JPRD), POINTER :: ZHOST3 (:,:,:)
INTEGER (KIND=JPIM) :: JBLK, JLEV, JLON, JFLD, JDIM

CALL PLOG ("SET_HOST_YLF3", KFLD)

DO JDIM = 1, SIZE (KFLD)

  JFLD = KFLD (JDIM)

  IF (JFLD < 1 .OR. NDIM < JFLD) THEN
    CALL ABOR1 ('UNEXPECTED JFLD')
  ENDIF

  ZHOST3 => GET_HOST_DATA_RDWR (YLF3L (JFLD)%PTR)

  CALL CHECK_DIMS_YLF3 (ZHOST3)

  DO JBLK = 1, NGPBLKS
    DO JLEV = 0, NFLEVG
      DO JLON = 1, NPROMA
        ZHOST3 (JLON, JLEV, JBLK) = FUNC (JLON, JLEV, JFLD, JBLK, ZCOEF)
      ENDDO
    ENDDO
  ENDDO

  CALL CHECK_STATUS

ENDDO

END SUBROUTINE

SUBROUTINE SET_DEVICE_YLF3 (KFLD)

INTEGER (KIND=JPIM), INTENT (IN) :: KFLD (:)

REAL (KIND=JPRD), POINTER :: ZDEVICE3 (:,:,:)
INTEGER (KIND=JPIM) :: JBLK, JLEV, JLON, JFLD, JDIM

CALL PLOG ("SET_DEVICE_YLF3", KFLD)

DO JDIM = 1, SIZE (KFLD)

  CALL CHECK_STATUS

  JFLD = KFLD (JDIM)

  IF (JFLD < 1 .OR. NDIM < JFLD) THEN
    CALL ABOR1 ('UNEXPECTED JFLD')
  ENDIF

  ZDEVICE3 => GET_DEVICE_DATA_RDWR (YLF3L (JFLD)%PTR)

  CALL CHECK_STATUS

  CALL CHECK_DIMS_YLF3 (ZDEVICE3)

!$acc update device (ZCOEF)

!$acc serial present (ZDEVICE3) 

  DO JBLK = 1, NGPBLKS
    DO JLEV = 0, NFLEVG
      DO JLON = 1, NPROMA
        ZDEVICE3 (JLON, JLEV, JBLK) = FUNC (JLON, JLEV, JFLD, JBLK, ZCOEF)
      ENDDO
    ENDDO
  ENDDO

!$acc end serial


  CALL CHECK_STATUS

ENDDO

END SUBROUTINE

SUBROUTINE GET_DEVICE_YLF3 (KFLD)

INTEGER (KIND=JPIM), INTENT (IN) :: KFLD (:)

REAL (KIND=JPRD), POINTER :: ZDEVICE3 (:,:,:)
INTEGER (KIND=JPIM) :: JBLK, JLEV, JLON, JFLD, JDIM

CALL PLOG ("GET_DEVICE_YLF3", KFLD)

DO JDIM = 1, SIZE (KFLD)

  JFLD = KFLD (JDIM)

  IF (JFLD < 1 .OR. NDIM < JFLD) THEN
    CALL ABOR1 ('UNEXPECTED JFLD')
  ENDIF

  ZDEVICE3 => GET_DEVICE_DATA_RDONLY (YLF3L (JFLD)%PTR)

  CALL CHECK_DIMS_YLF3 (ZDEVICE3)


!$acc update device (ZCOEF)

!$acc serial present (ZDEVICE3) 

  DO JBLK = 1, NGPBLKS
    DO JLEV = 0, NFLEVG
      DO JLON = 1, NPROMA
        IF (ZDEVICE3 (JLON, JLEV, JBLK) /= FUNC (JLON, JLEV, JFLD, JBLK, ZCOEF)) THEN
          PRINT *, ZDEVICE3 (JLON, JLEV, JBLK)
          PRINT *,  FUNC (JLON, JLEV, JFLD, JBLK, ZCOEF)
          CALL ABOR1 ('VALUE MISMATCH')
        ENDIF
      ENDDO
    ENDDO
  ENDDO

!$acc end serial


  CALL CHECK_STATUS

ENDDO

END SUBROUTINE

SUBROUTINE GET_HOST_YLF3 (KFLD)

INTEGER (KIND=JPIM), INTENT (IN) :: KFLD (:)

REAL (KIND=JPRD), POINTER :: ZHOST3 (:,:,:)
INTEGER (KIND=JPIM) :: JBLK, JLEV, JLON, JFLD, JDIM

CALL PLOG ("GET_HOST_YLF3", KFLD)

DO JDIM = 1, SIZE (KFLD)

  JFLD = KFLD (JDIM)

  IF (JFLD < 1 .OR. NDIM < JFLD) THEN
    CALL ABOR1 ('UNEXPECTED JFLD')
  ENDIF

  ZHOST3 => GET_HOST_DATA_RDONLY (YLF3L (JFLD)%PTR)

  CALL CHECK_DIMS_YLF3 (ZHOST3)

  DO JBLK = 1, NGPBLKS
    DO JLEV = 0, NFLEVG
      DO JLON = 1, NPROMA
        IF (ZHOST3 (JLON, JLEV, JBLK) /= FUNC (JLON, JLEV, JFLD, JBLK, ZCOEF)) THEN
          PRINT *, JLON, JLEV, JBLK
          PRINT *, ZHOST3 (JLON, JLEV, JBLK)
          PRINT *,  FUNC (JLON, JLEV, JFLD, JBLK, ZCOEF)
          CALL ABOR1 ('VALUE MISMATCH')
        ENDIF
      ENDDO
    ENDDO
  ENDDO

  CALL CHECK_STATUS

ENDDO

END SUBROUTINE

SUBROUTINE CHECK_STATUS

INTEGER (KIND=JPIM) :: JFLD

DO JFLD = 1, NDIM
  IF (.NOT. ASSOCIATED (YLF3L(JFLD)%PTR%PARENT, YLF4)) THEN
    PRINT *, JFLD
    PRINT *, ASSOCIATED (YLF3L(JFLD)%PTR%PARENT)
    CALL ABOR1 ('PARENT MISMATCH')
  ENDIF
  IF (YLF4%ISTATUS /= YLF3L(JFLD)%PTR%ISTATUS) THEN
    PRINT *, JFLD
    WRITE (*, '("YLF4 = ",Z16.16)') YLF4%ISTATUS
    WRITE (*, '("YLF3L (",I0,")=",Z16.16)') JFLD, YLF3L(JFLD)%PTR%ISTATUS
    CALL ABOR1 ('STATUS MISMATCH')
  ENDIF
ENDDO

END SUBROUTINE

SUBROUTINE PLOG (CDNAME, KFLD)

CHARACTER (LEN=*), INTENT (IN) :: CDNAME
INTEGER (KIND=JPIM), INTENT (IN), OPTIONAL :: KFLD (:)

INTEGER (KIND=JPIM) :: JDIM, JSPC

IF (LLVERBOSE) THEN

  WRITE (*, '(A)', ADVANCE='NO') CDNAME

  DO JSPC = LEN (CDNAME), 16
    WRITE (*, '(A)', ADVANCE='NO') ' '
  ENDDO
  
  IF (PRESENT (KFLD)) THEN
    WRITE (*, '("(")', ADVANCE='NO')
    DO JDIM = 1, SIZE (KFLD)
      WRITE (*, '(I0)', ADVANCE='NO') KFLD (JDIM)
      
      IF (JDIM < SIZE (KFLD)) WRITE (*, '(",")', ADVANCE='NO')
    ENDDO
    WRITE (*, '(")")', ADVANCE='NO')
  ENDIF

  WRITE (*, *)

ENDIF

END SUBROUTINE

END PROGRAM 
