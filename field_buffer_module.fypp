#! (C) Copyright 2022- ECMWF.
#! (C) Copyright 2022- Meteo-France.
#!
#! This software is licensed under the terms of the Apache Licence Version 2.0
#! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
#! In applying this licence, ECMWF does not waive the privileges and immunities
#! granted to it by virtue of its status as an intergovernmental organisation
#! nor does it submit to any jurisdiction.

MODULE FIELD_BUFFER_MODULE

#:set fieldTypeList = fieldType.getFieldTypeList(ranks=[3,4,5])

USE FIELD_MODULE
USE FIELD_FACTORY_MODULE
USE OML_MOD, ONLY: OML_MY_THREAD 
${fieldType.useParkind1 ()}$

IMPLICIT NONE

#:for ft in fieldTypeList
#:set ftn = ft.name + '_BUFFER'
TYPE ${ftn}$ 
   CLASS(${ft.name}$), POINTER :: BUFFER => NULL()
   INTEGER(KIND=JPIM) :: NUM_FIELDS = 0
   LOGICAL :: CONTIG_FIELDS = .FALSE.
   TYPE(${f'FIELD_{ft.rank-1}{ft.suffix}'}$_PTR), POINTER, PRIVATE :: FIELDS(:) => NULL()

CONTAINS

   PROCEDURE :: ${ftn}$_INIT_WRAPPER
   PROCEDURE :: ${ftn}$_INIT_OWNER
   GENERIC :: INIT => ${ftn}$_INIT_WRAPPER, ${ftn}$_INIT_OWNER
   PROCEDURE, PRIVATE :: ASSIGN_FIELDS => ${ftn}$_ASSIGN_FIELDS
   PROCEDURE :: FINAL => ${ftn}$_FINAL
   PROCEDURE :: GET_VIEW => ${ftn}$_GET_VIEW
   PROCEDURE :: GET_DEVICE_DATA_RDONLY => ${ftn}$_GET_DEVICE_DATA_RDONLY
   PROCEDURE :: GET_DEVICE_DATA_RDWR => ${ftn}$_GET_DEVICE_DATA_RDWR
   PROCEDURE :: GET_HOST_DATA_RDONLY => ${ftn}$_GET_HOST_DATA_RDONLY
   PROCEDURE :: GET_HOST_DATA_RDWR => ${ftn}$_GET_HOST_DATA_RDWR
   PROCEDURE :: SYNC_HOST_RDWR => ${ftn}$_SYNC_HOST_RDWR
   PROCEDURE :: SYNC_HOST_RDONLY => ${ftn}$_SYNC_HOST_RDONLY
   PROCEDURE :: SYNC_DEVICE_RDWR => ${ftn}$_SYNC_DEVICE_RDWR
   PROCEDURE :: SYNC_DEVICE_RDONLY => ${ftn}$_SYNC_DEVICE_RDONLY
END TYPE ${ftn}$ 

#:endfor

CONTAINS

#:for ft in fieldTypeList
#:set ftn = ft.name + '_BUFFER'
SUBROUTINE ${ftn}$_INIT_WRAPPER(SELF, NUM_FIELDS, FIELDS, DATA, LBOUNDS, CONTIG_FIELDS, PERSISTENT)
  CLASS(${ftn}$) :: SELF
  INTEGER(KIND=JPIM), INTENT(IN) :: NUM_FIELDS
  TYPE(${f'FIELD_{ft.rank-1}{ft.suffix}'}$_PTR), TARGET, INTENT(INOUT) :: FIELDS(NUM_FIELDS)

  ${ft.type}$, TARGET, INTENT(IN) :: DATA(${ft.shape}$)
  LOGICAL, INTENT(IN), OPTIONAL :: CONTIG_FIELDS, PERSISTENT
  INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(${ft.rank}$)
  INTEGER(KIND=JPIM) :: LLBOUNDS(${ft.rank}$)
  LOGICAL :: LLPERSISTENT

  SELF%NUM_FIELDS = NUM_FIELDS
  IF(PRESENT(CONTIG_FIELDS)) SELF%CONTIG_FIELDS = CONTIG_FIELDS

  !...Consistency checks
  IF(SELF%CONTIG_FIELDS)THEN
     IF(UBOUND(DATA, ${ft.rank}$) /= NUM_FIELDS)THEN
        CALL ABOR1('${ftn}$_WRAPPER: DIMENSION MISMATCH')
     ENDIF
  ELSE
     IF(UBOUND(DATA, ${ft.rank-1}$) /= NUM_FIELDS)THEN
        CALL ABOR1('${ftn}$_WRAPPER: DIMENSION MISMATCH')
     ENDIF
  ENDIF

  !...Wrapper fields are persistent by default
  LLPERSISTENT = .TRUE.
  IF(PRESENT(PERSISTENT)) LLPERSISTENT = PERSISTENT

  IF(.NOT. LLPERSISTENT .AND. SELF%CONTIG_FIELDS)THEN
      CALL ABOR1('${ftn}$_WRAPPER: Thread-local temporaries must be block-strided')
  ENDIF
  
  !...Set lower bounds
  LLBOUNDS(:) =  1
  IF(PRESENT(LBOUNDS)) LLBOUNDS = LBOUNDS
  IF(SELF%CONTIG_FIELDS)THEN
    LLBOUNDS(${ft.rank}$) = 1
  ELSE
    LLBOUNDS(${ft.rank-1}$) = 1
  ENDIF

  CALL FIELD_NEW(SELF%BUFFER, DATA=DATA, LBOUNDS=LLBOUNDS, PERSISTENT=LLPERSISTENT)
  CALL SELF%ASSIGN_FIELDS(FIELDS, LLPERSISTENT)
  SELF%FIELDS => FIELDS

END SUBROUTINE ${ftn}$_INIT_WRAPPER

SUBROUTINE ${ftn}$_INIT_OWNER(SELF, NUM_FIELDS, FIELDS, UBOUNDS, CONTIG_FIELDS, LBOUNDS, PERSISTENT)
  CLASS(${ftn}$) :: SELF
  INTEGER(KIND=JPIM), INTENT(IN) :: NUM_FIELDS
  TYPE(${f'FIELD_{ft.rank-1}{ft.suffix}'}$_PTR), TARGET, INTENT(INOUT) :: FIELDS(NUM_FIELDS)

  INTEGER(KIND=JPIM), INTENT(IN) :: UBOUNDS(${ft.rank}$)
  INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(${ft.rank}$)
  LOGICAL, INTENT(IN), OPTIONAL :: CONTIG_FIELDS, PERSISTENT

  INTEGER(KIND=JPIM) :: LLBOUNDS(${ft.rank}$)
  LOGICAL :: LLPERSISTENT

  SELF%NUM_FIELDS = NUM_FIELDS
  IF(PRESENT(CONTIG_FIELDS)) SELF%CONTIG_FIELDS = CONTIG_FIELDS

  !...Consistency checks
  IF(SELF%CONTIG_FIELDS)THEN
     IF(UBOUNDS(${ft.rank}$) /= NUM_FIELDS)THEN
        CALL ABOR1('${ftn}$_OWNER: DIMENSION MISMATCH')
     ENDIF
  ELSE
     IF(UBOUNDS(${ft.rank-1}$) /= NUM_FIELDS)THEN
        CALL ABOR1('${ftn}$_OWNER: DIMENSION MISMATCH')
     ENDIF
  ENDIF

  !...Owner fields are thread-local by default
  LLPERSISTENT = .FALSE.
  IF(PRESENT(PERSISTENT)) LLPERSISTENT = PERSISTENT

  IF(.NOT. LLPERSISTENT .AND. SELF%CONTIG_FIELDS)THEN
      CALL ABOR1('${ftn}$_OWNER: Thread-local temporaries must be block-strided')
  ENDIF

  !...Set lower bounds
  LLBOUNDS(:) =  1
  IF(PRESENT(LBOUNDS)) LLBOUNDS = LBOUNDS
  IF(SELF%CONTIG_FIELDS)THEN
    LLBOUNDS(${ft.rank}$) = 1
  ELSE
    LLBOUNDS(${ft.rank-1}$) = 1
  ENDIF

  CALL FIELD_NEW(SELF%BUFFER, UBOUNDS=UBOUNDS, LBOUNDS=LLBOUNDS, PERSISTENT=LLPERSISTENT)
  CALL SELF%ASSIGN_FIELDS(FIELDS, LLPERSISTENT)
  SELF%FIELDS => FIELDS

END SUBROUTINE ${ftn}$_INIT_OWNER

SUBROUTINE ${ftn}$_ASSIGN_FIELDS(SELF, FIELDS, PERSISTENT)
  CLASS(${ftn}$) :: SELF
  TYPE(${f'FIELD_{ft.rank-1}{ft.suffix}'}$_PTR), INTENT(INOUT) :: FIELDS(:)
  LOGICAL, INTENT(IN) :: PERSISTENT

  INTEGER(KIND=JPIM), DIMENSION(${ft.rank-1}$) :: LBOUNDS
  INTEGER(KIND=JPIM) :: IFIELD

  IF(SELF%CONTIG_FIELDS)THEN
     #:for r in range(1, ft.rank)
     LBOUNDS(${r}$) = LBOUND(SELF%BUFFER%PTR, ${r}$)
     #:endfor

     #:set ar = (',').join([':' for _ in range(0, ft.rank-1)])
     DO IFIELD=1,SELF%NUM_FIELDS
        CALL FIELD_NEW(FIELDS(IFIELD)%PTR, DATA=SELF%BUFFER%PTR(${ar}$,IFIELD), LBOUNDS=LBOUNDS, PERSISTENT=PERSISTENT)
     ENDDO
  ELSE
     #:for r in range(1, ft.rank-1)
     LBOUNDS(${r}$) = LBOUND(SELF%BUFFER%PTR, ${r}$)
     #:endfor
     LBOUNDS(${ft.rank-1}$) = LBOUND(SELF%BUFFER%PTR, ${ft.rank}$)

     #:set ar = (',').join([':' for _ in range(0, ft.rank-2)])
     DO IFIELD=1,SELF%NUM_FIELDS
        CALL FIELD_NEW(FIELDS(IFIELD)%PTR, DATA=SELF%BUFFER%PTR(${ar}$,IFIELD,:), LBOUNDS=LBOUNDS, PERSISTENT=PERSISTENT)
     ENDDO
  ENDIF

END SUBROUTINE ${ftn}$_ASSIGN_FIELDS

SUBROUTINE ${ftn}$_GET_HOST_DATA_RDWR(SELF, PPTR, QUEUE)
    CLASS(${ftn}$),   INTENT(INOUT) :: SELF
    ${ft.type}$, POINTER,         INTENT(INOUT) :: PPTR(${ft.shape}$)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    INTEGER(KIND=JPIM) :: IFIELD

    CALL SELF%BUFFER%GET_HOST_DATA_RDWR(PPTR, QUEUE=QUEUE)

    DO IFIELD=1,SELF%NUM_FIELDS
       SELF%FIELDS(IFIELD)%PTR%ISTATUS = SELF%BUFFER%ISTATUS
    ENDDO

END SUBROUTINE ${ftn}$_GET_HOST_DATA_RDWR

SUBROUTINE ${ftn}$_GET_DEVICE_DATA_RDWR(SELF, PPTR, QUEUE)
    CLASS(${ftn}$),   INTENT(INOUT) :: SELF
    ${ft.type}$, POINTER,         INTENT(INOUT) :: PPTR(${ft.shape}$)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    INTEGER(KIND=JPIM) :: IFIELD

    CALL SELF%BUFFER%GET_DEVICE_DATA_RDWR(PPTR, QUEUE=QUEUE)

    DO IFIELD=1,SELF%NUM_FIELDS
       SELF%FIELDS(IFIELD)%PTR%ISTATUS = SELF%BUFFER%ISTATUS
    ENDDO

    IF(.NOT. ASSOCIATED(SELF%FIELDS(1)%PTR%DEVPTR))THEN
       IF(SELF%CONTIG_FIELDS)THEN
          #:set ar = (',').join([':' for _ in range(0, ft.rank-1)])
          DO IFIELD=1,SELF%NUM_FIELDS
             SELF%FIELDS(IFIELD)%PTR%DEVPTR => SELF%BUFFER%DEVPTR(${ar}$,IFIELD)
          ENDDO
       ELSE
          #:set ar = (',').join([':' for _ in range(0, ft.rank-2)])
          DO IFIELD=1,SELF%NUM_FIELDS
             SELF%FIELDS(IFIELD)%PTR%DEVPTR => SELF%BUFFER%DEVPTR(${ar}$,IFIELD,:)
          ENDDO
       ENDIF
    ENDIF

END SUBROUTINE ${ftn}$_GET_DEVICE_DATA_RDWR

SUBROUTINE ${ftn}$_GET_HOST_DATA_RDONLY(SELF, PPTR, QUEUE)
    CLASS(${ftn}$),   INTENT(INOUT) :: SELF
    ${ft.type}$, POINTER,         INTENT(INOUT) :: PPTR(${ft.shape}$)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    INTEGER(KIND=JPIM) :: IFIELD

    CALL SELF%BUFFER%GET_HOST_DATA_RDONLY(PPTR, QUEUE=QUEUE)

    DO IFIELD=1,SELF%NUM_FIELDS
       SELF%FIELDS(IFIELD)%PTR%ISTATUS = SELF%BUFFER%ISTATUS
    ENDDO

END SUBROUTINE ${ftn}$_GET_HOST_DATA_RDONLY

SUBROUTINE ${ftn}$_GET_DEVICE_DATA_RDONLY(SELF, PPTR, QUEUE)
    CLASS(${ftn}$),   INTENT(INOUT) :: SELF
    ${ft.type}$, POINTER,         INTENT(INOUT) :: PPTR(${ft.shape}$)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    INTEGER(KIND=JPIM) :: IFIELD

    CALL SELF%BUFFER%GET_DEVICE_DATA_RDONLY(PPTR, QUEUE=QUEUE)

    DO IFIELD=1,SELF%NUM_FIELDS
       SELF%FIELDS(IFIELD)%PTR%ISTATUS = SELF%BUFFER%ISTATUS
    ENDDO

    IF(.NOT. ASSOCIATED(SELF%FIELDS(1)%PTR%DEVPTR))THEN
       IF(SELF%CONTIG_FIELDS)THEN
          #:set ar = (',').join([':' for _ in range(0, ft.rank-1)])
          DO IFIELD=1,SELF%NUM_FIELDS
             SELF%FIELDS(IFIELD)%PTR%DEVPTR => SELF%BUFFER%DEVPTR(${ar}$,IFIELD)
          ENDDO
       ELSE
          #:set ar = (',').join([':' for _ in range(0, ft.rank-2)])
          DO IFIELD=1,SELF%NUM_FIELDS
             SELF%FIELDS(IFIELD)%PTR%DEVPTR => SELF%BUFFER%DEVPTR(${ar}$,IFIELD,:)
          ENDDO
       ENDIF
    ENDIF

END SUBROUTINE ${ftn}$_GET_DEVICE_DATA_RDONLY

SUBROUTINE ${ftn}$_SYNC_HOST_RDWR(SELF, QUEUE)
    CLASS(${ftn}$),   INTENT(INOUT) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    ${ft.type}$, POINTER :: PPTR(${ft.shape}$)
    INTEGER(KIND=JPIM) :: IFIELD

    CALL SELF%BUFFER%GET_HOST_DATA_RDWR(PPTR, QUEUE=QUEUE)

    DO IFIELD=1,SELF%NUM_FIELDS
       SELF%FIELDS(IFIELD)%PTR%ISTATUS = SELF%BUFFER%ISTATUS
    ENDDO

END SUBROUTINE ${ftn}$_SYNC_HOST_RDWR

SUBROUTINE ${ftn}$_SYNC_HOST_RDONLY(SELF, QUEUE)
    CLASS(${ftn}$),   INTENT(INOUT) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    ${ft.type}$, POINTER :: PPTR(${ft.shape}$)
    INTEGER(KIND=JPIM) :: IFIELD

    CALL SELF%BUFFER%GET_HOST_DATA_RDONLY(PPTR, QUEUE=QUEUE)

    DO IFIELD=1,SELF%NUM_FIELDS
       SELF%FIELDS(IFIELD)%PTR%ISTATUS = SELF%BUFFER%ISTATUS
    ENDDO

END SUBROUTINE ${ftn}$_SYNC_HOST_RDONLY

SUBROUTINE ${ftn}$_SYNC_DEVICE_RDWR(SELF, QUEUE)
    CLASS(${ftn}$),   INTENT(INOUT) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    ${ft.type}$, POINTER :: PPTR(${ft.shape}$)
    INTEGER(KIND=JPIM) :: IFIELD

    CALL SELF%BUFFER%GET_DEVICE_DATA_RDWR(PPTR, QUEUE=QUEUE)

    DO IFIELD=1,SELF%NUM_FIELDS
       SELF%FIELDS(IFIELD)%PTR%ISTATUS = SELF%BUFFER%ISTATUS
    ENDDO

    IF(.NOT. ASSOCIATED(SELF%FIELDS(1)%PTR%DEVPTR))THEN
       IF(SELF%CONTIG_FIELDS)THEN
          #:set ar = (',').join([':' for _ in range(0, ft.rank-1)])
          DO IFIELD=1,SELF%NUM_FIELDS
             SELF%FIELDS(IFIELD)%PTR%DEVPTR => SELF%BUFFER%DEVPTR(${ar}$,IFIELD)
          ENDDO
       ELSE
          #:set ar = (',').join([':' for _ in range(0, ft.rank-2)])
          DO IFIELD=1,SELF%NUM_FIELDS
             SELF%FIELDS(IFIELD)%PTR%DEVPTR => SELF%BUFFER%DEVPTR(${ar}$,IFIELD,:)
          ENDDO
       ENDIF
    ENDIF

END SUBROUTINE ${ftn}$_SYNC_DEVICE_RDWR

SUBROUTINE ${ftn}$_SYNC_DEVICE_RDONLY(SELF, QUEUE)
    CLASS(${ftn}$),   INTENT(INOUT) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    ${ft.type}$, POINTER :: PPTR(${ft.shape}$)
    INTEGER(KIND=JPIM) :: IFIELD

    CALL SELF%BUFFER%GET_DEVICE_DATA_RDONLY(PPTR, QUEUE=QUEUE)

    DO IFIELD=1,SELF%NUM_FIELDS
       SELF%FIELDS(IFIELD)%PTR%ISTATUS = SELF%BUFFER%ISTATUS
    ENDDO

    IF(.NOT. ASSOCIATED(SELF%FIELDS(1)%PTR%DEVPTR))THEN
       IF(SELF%CONTIG_FIELDS)THEN
          #:set ar = (',').join([':' for _ in range(0, ft.rank-1)])
          DO IFIELD=1,SELF%NUM_FIELDS
             SELF%FIELDS(IFIELD)%PTR%DEVPTR => SELF%BUFFER%DEVPTR(${ar}$,IFIELD)
          ENDDO
       ELSE
          #:set ar = (',').join([':' for _ in range(0, ft.rank-2)])
          DO IFIELD=1,SELF%NUM_FIELDS
             SELF%FIELDS(IFIELD)%PTR%DEVPTR => SELF%BUFFER%DEVPTR(${ar}$,IFIELD,:)
          ENDDO
       ENDIF
    ENDIF

END SUBROUTINE ${ftn}$_SYNC_DEVICE_RDONLY

FUNCTION ${ftn}$_GET_VIEW(SELF, BLOCK_INDEX, ZERO) RESULT(VIEW_PTR)
  CLASS(${ftn}$) :: SELF
  ${ft.type}$, POINTER :: VIEW_PTR(${ft.viewShape}$)
  INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
  LOGICAL, OPTIONAL,  INTENT(IN) :: ZERO
  INTEGER(KIND=JPIM) :: IDX, IFIELD
  INTEGER(KIND=JPIM) :: LBOUNDS(${ft.rank}$)
  INTEGER(KIND=JPIM) :: LLBOUNDS(${ft.rank-1}$)

  IDX = BLOCK_INDEX
  IF (SELF%BUFFER%THREAD_BUFFER) IDX = OML_MY_THREAD ()

  LBOUNDS=LBOUND(SELF%BUFFER%PTR)
  IF(SELF%CONTIG_FIELDS)THEN
    VIEW_PTR(${','.join('LBOUNDS(%d):'%(r+1) for r in range(ft.viewRank))}$) => SELF%BUFFER%PTR(${','.join(':' for _ in range(ft.viewRank-1))}$,IDX,:)
  ELSE
    VIEW_PTR(${','.join('LBOUNDS(%d):'%(r+1) for r in range(ft.viewRank))}$) => SELF%BUFFER%PTR(${','.join(':' for _ in range(ft.viewRank))}$,IDX)
  ENDIF

  IF (PRESENT(ZERO)) THEN
    IF (ZERO) VIEW_PTR(${ft.viewShape}$) = ${ft.default}$
  END IF

END FUNCTION ${ftn}$_GET_VIEW

SUBROUTINE ${ftn}$_FINAL(SELF)
  CLASS(${ftn}$) :: SELF
  INTEGER(KIND=JPIM) :: IFIELD

  DO IFIELD=1,SELF%NUM_FIELDS
     CALL FIELD_DELETE(SELF%FIELDS(IFIELD)%PTR)
  ENDDO
  NULLIFY(SELF%FIELDS)

  CALL FIELD_DELETE(SELF%BUFFER)
  NULLIFY(SELF%BUFFER)

END SUBROUTINE ${ftn}$_FINAL

#:endfor

END MODULE FIELD_BUFFER_MODULE
