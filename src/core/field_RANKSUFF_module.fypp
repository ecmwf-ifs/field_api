#! (C) Copyright 2022- ECMWF.
#! (C) Copyright 2022- Meteo-France.
#! (C) Copyright 2023- NVIDIA
#!
#! This software is licensed under the terms of the Apache Licence Version 2.0
#! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
#! In applying this licence, ECMWF does not waive the privileges and immunities
#! granted to it by virtue of its status as an intergovernmental organisation
#! nor does it submit to any jurisdiction.

MODULE FIELD_${RANK}$${SUFF}$_MODULE

#:set fieldTypeList = fieldType.getFieldTypeList (ranks=[RANK], kinds=['JP' + str (SUFF)])

USE OML_MOD, ONLY: OML_MAX_THREADS , OML_MY_THREAD 
USE IEEE_ARITHMETIC, ONLY: IEEE_SIGNALING_NAN
USE DEV_ALLOC_MODULE
USE HOST_ALLOC_MODULE
USE FIELD_BASIC_MODULE
USE FIELD_CONSTANTS_MODULE
USE FIELD_DEFAULTS_MODULE
${fieldType.useParkind1 ()}$

#:for ft in fieldTypeList
#:set ftn = ft.name
USE FIELD_${RANK}$${SUFF}$_DATA_MODULE, ONLY : ${ftn}$_COPY_INTF
#:endfor

IMPLICIT NONE

PRIVATE

#:for ft in fieldTypeList
#:set ftn = ft.name
TYPE, ABSTRACT, EXTENDS (FIELD_BASIC) :: ${ftn}$
  ${ft.type}$, POINTER :: PTR(${ft.shape}$) => NULL()
#ifdef _CRAYFTN
  ${ft.type}$, POINTER :: DEVPTR(${ft.shape}$) => NULL()
#else
  ${ft.type}$, POINTER, CONTIGUOUS :: DEVPTR(${ft.shape}$) => NULL()
#endif
  INTEGER(KIND=JPIM) :: LBOUNDS(${ft.rank}$), UBOUNDS(${ft.rank}$)
  PROCEDURE (${ftn}$_COPY_INTF), POINTER, NOPASS :: COPY_FUNC => NULL ()
CONTAINS

  PROCEDURE :: FINAL => ${ftn}$_FINAL
  PROCEDURE :: ${ftn}$_FINAL
  PROCEDURE :: DELETE_DEVICE_DATA => ${ftn}$_DELETE_DEVICE_DATA
#:if ft.hasView
  PROCEDURE :: GET_VIEW => ${ftn}$_GET_VIEW
#:endif
  PROCEDURE :: GET_DEVICE_DATA_RDONLY => ${ftn}$_GET_DEVICE_DATA_RDONLY
  PROCEDURE :: GET_DEVICE_DATA_WRONLY => ${ftn}$_GET_DEVICE_DATA_WRONLY
  PROCEDURE :: GET_DEVICE_DATA_RDWR => ${ftn}$_GET_DEVICE_DATA_RDWR
  PROCEDURE :: GET_DEVICE_DATA_FORCE => ${ftn}$_GET_DEVICE_DATA_FORCE
  PROCEDURE :: GET_HOST_DATA_RDONLY => ${ftn}$_GET_HOST_DATA_RDONLY
  PROCEDURE :: GET_HOST_DATA_RDWR => ${ftn}$_GET_HOST_DATA_RDWR
  PROCEDURE :: GET_HOST_DATA_FORCE => ${ftn}$_GET_HOST_DATA_FORCE
  PROCEDURE :: SYNC_HOST_RDWR => ${ftn}$_SYNC_HOST_RDWR
  PROCEDURE :: SYNC_HOST_RDONLY => ${ftn}$_SYNC_HOST_RDONLY
  PROCEDURE :: SYNC_HOST_FORCE => ${ftn}$_SYNC_HOST_FORCE
  PROCEDURE :: SYNC_DEVICE_RDWR => ${ftn}$_SYNC_DEVICE_RDWR
  PROCEDURE :: SYNC_DEVICE_RDONLY => ${ftn}$_SYNC_DEVICE_RDONLY
  PROCEDURE :: SYNC_DEVICE_WRONLY => ${ftn}$_SYNC_DEVICE_WRONLY
  PROCEDURE :: SYNC_DEVICE_FORCE => ${ftn}$_SYNC_DEVICE_FORCE
  PROCEDURE :: COPY_OBJECT => ${ftn}$_COPY_OBJECT
  PROCEDURE :: WIPE_OBJECT => ${ftn}$_WIPE_OBJECT
  PROCEDURE :: GET_DIMS => ${ftn}$_GET_DIMS
  PROCEDURE(RESIZE), DEFERRED :: RESIZE

  PROCEDURE :: GET_DEVICE_DATA => ${ftn}$_GET_DEVICE_DATA
  PROCEDURE :: GET_DEVICE_POINTER => ${ftn}$_GET_DEVICE_POINTER
  PROCEDURE :: GET_HOST_DATA => ${ftn}$_GET_HOST_DATA
  PROCEDURE :: GET_HOST_POINTER => ${ftn}$_GET_HOST_POINTER
  PROCEDURE, PRIVATE :: ${ftn}$_GET_HOST_DATA
  PROCEDURE, PRIVATE :: ${ftn}$_GET_DEVICE_DATA

  PROCEDURE, PRIVATE :: COPY_DATA =>  ${ftn}$_COPY_DATA
  PROCEDURE :: CREATE_DEVICE_DATA => ${ftn}$_CREATE_DEVICE_DATA
#:if defined('WITH_FIAT')
  PROCEDURE :: CRC64 => ${ftn}$_CRC64
#:endif
#ifdef __PGI
  PROCEDURE :: SET_STATUS => ${ftn}$_SET_STATUS
#endif
END TYPE ${ftn}$

ABSTRACT INTERFACE
  SUBROUTINE RESIZE (SELF, UBOUNDS, LBOUNDS, PERSISTENT)
    ${fieldType.useParkind1 ()}$
    IMPORT ::  ${ftn}$
    CLASS(${ftn}$),               INTENT(IN) :: SELF
    INTEGER(KIND=JPIM),           INTENT(IN) :: UBOUNDS(${ft.rank}$)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS(${ft.rank}$)
    LOGICAL, OPTIONAL,            INTENT(IN) :: PERSISTENT
  END SUBROUTINE RESIZE
END INTERFACE

PUBLIC :: ${ftn}$

TYPE, EXTENDS(${ftn}$) :: ${ftn}$_WRAPPER
  LOGICAL :: SYNC_ON_FINAL = .TRUE.
CONTAINS
  PROCEDURE :: INIT => ${ftn}$_WRAPPER_INIT
  PROCEDURE :: FINAL => ${ftn}$_WRAPPER_FINAL
  PROCEDURE :: RESIZE => ${ftn}$_WRAPPER_RESIZE
END TYPE ${ftn}$_WRAPPER

PUBLIC :: ${ftn}$_WRAPPER

TYPE, EXTENDS(${ftn}$) :: ${ftn}$_OWNER
  LOGICAL :: HAS_INIT_VALUE = .FALSE.
  LOGICAL :: PINNED = .FALSE.
  LOGICAL :: POOLED = .FALSE.
  ${ft.type}$ :: INIT_VALUE
CONTAINS
  PROCEDURE :: INIT => ${ftn}$_OWNER_INIT
  PROCEDURE :: FINAL => ${ftn}$_OWNER_FINAL
  PROCEDURE, PRIVATE :: CREATE_HOST_DATA => ${ftn}$_OWNER_CREATE_HOST_DATA
  PROCEDURE :: GET_HOST_DATA => ${ftn}$_OWNER_GET_HOST_DATA
  PROCEDURE :: GET_DEVICE_DATA => ${ftn}$_OWNER_GET_DEVICE_DATA
  PROCEDURE :: RESIZE => ${ftn}$_OWNER_RESIZE
END TYPE ${ftn}$_OWNER

PUBLIC :: ${ftn}$_OWNER

TYPE ${ftn}$_PTR
  CLASS(${ftn}$), POINTER :: PTR => NULL()
END TYPE ${ftn}$_PTR

PUBLIC :: ${ftn}$_PTR

#:if ft.hasView
TYPE ${ftn}$_VIEW
  ${ft.type}$, POINTER :: P(${ft.viewShape}$) => NULL()
END TYPE ${ftn}$_VIEW

PUBLIC :: ${ftn}$_VIEW
#:endif

#:endfor

CONTAINS

#:for ft in fieldTypeList
#:set ftn = ft.name
  SUBROUTINE ${ftn}$_WRAPPER_INIT(SELF, DATA, PERSISTENT, LBOUNDS, MAP_DEVPTR, SYNC_ON_FINAL, INITIALIZED)
    USE FIELD_ABORT_MODULE
    USE FIELD_DEFAULTS_MODULE
    USE ${ftn}$_DATA_MODULE, ONLY : ${ftn}$_COPY_FUNC

    ! Create FIELD object by wrapping existing data
    CLASS(${ftn}$_WRAPPER) :: SELF
    ${ft.type}$, TARGET, INTENT(IN) :: DATA(${ft.shape}$)
    LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
    LOGICAL, INTENT(IN), OPTIONAL :: MAP_DEVPTR
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(${ft.rank}$)
    LOGICAL, INTENT(IN), OPTIONAL :: SYNC_ON_FINAL
    LOGICAL, INTENT(IN), OPTIONAL :: INITIALIZED
    
    LOGICAL :: LLPERSISTENT
    LOGICAL :: LLINITIALIZED

#include "abor1.intfb.h"

    LLPERSISTENT = .TRUE.
    IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT

    LLINITIALIZED = .TRUE.
    IF (PRESENT (INITIALIZED)) LLINITIALIZED = INITIALIZED

    IF (PRESENT(LBOUNDS)) THEN
      SELF%PTR(${ft.lbptr}$) => DATA
    ELSE
      SELF%PTR => DATA
    ENDIF
    SELF%LBOUNDS=LBOUND(SELF%PTR)
    SELF%UBOUNDS=UBOUND(SELF%PTR)

    SELF%THREAD_BUFFER = .NOT. LLPERSISTENT

    IF (LLINITIALIZED) THEN
      CALL SELF%SET_STATUS (NHSTFRESH)
    ELSE
      CALL SELF%SET_STATUS (UNINITIALIZED)
    ENDIF

    SELF%MAP_DEVPTR = INIT_MAP_DEVPTR
    IF(PRESENT(MAP_DEVPTR))THEN
      SELF%MAP_DEVPTR = MAP_DEVPTR
    ENDIF
#:if not defined('WITH_HIC')
    IF(.NOT. SELF%MAP_DEVPTR)THEN
       CALL FIELD_ABORT ("${ftn}$_WRAPPER_INIT: CUDA backend needed to disable host-mapped device-pointer")
    ENDIF
#:endif

    SELF%SYNC_ON_FINAL = INIT_SYNC_ON_FINAL
    IF (PRESENT (SYNC_ON_FINAL)) THEN
      SELF%SYNC_ON_FINAL = SYNC_ON_FINAL
    ENDIF

    IF (.NOT. LLPERSISTENT) THEN
      IF (OML_MAX_THREADS () /= SIZE (DATA, ${ft.rank}$)) THEN
        CALL FIELD_ABORT ('${ftn}$_WRAPPER_INIT: DIMENSION MISMATCH')
      ENDIF
    ENDIF

    IF (SIZE(DATA) > 0) THEN
      SELF%COPY_FUNC => ${ftn}$_COPY_FUNC (SELF%PTR, SELF%DEVPTR)
    ELSE
      SELF%COPY_FUNC => ${ftn}$_COPY_FUNC ()
    END IF

  END SUBROUTINE ${ftn}$_WRAPPER_INIT

  SUBROUTINE ${ftn}$_OWNER_INIT (SELF, LBOUNDS, UBOUNDS, PERSISTENT, DELAYED, INIT_VALUE, PINNED, MAP_DEVPTR, POOLED)
    USE FIELD_ABORT_MODULE 
    USE ${ftn}$_DATA_MODULE, ONLY : ${ftn}$_COPY_FUNC
    USE FIELD_DEFAULTS_MODULE, ONLY: DELAYED_DEFAULT_VALUE

    CLASS(${ftn}$_OWNER) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(${ft.rank}$)
    INTEGER(KIND=JPIM), INTENT(IN) :: UBOUNDS(${ft.rank}$)
    LOGICAL, OPTIONAL,  INTENT(IN) :: PERSISTENT
    LOGICAL, OPTIONAL,  INTENT(IN) :: DELAYED
    LOGICAL, OPTIONAL,  INTENT(IN) :: PINNED
    LOGICAL, OPTIONAL,  INTENT(IN) :: MAP_DEVPTR
    LOGICAL, OPTIONAL,  INTENT(IN) :: POOLED
    ${ft.type}$, OPTIONAL, INTENT(IN) :: INIT_VALUE

    LOGICAL :: IS_DELAYED
    LOGICAL :: LLPERSISTENT

#include "abor1.intfb.h"

    IS_DELAYED = DELAYED_DEFAULT_VALUE
    IF(PRESENT(DELAYED))THEN
      IS_DELAYED = DELAYED
    ENDIF

    LLPERSISTENT = .FALSE.
    IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT

    SELF%POOLED = POOL_OWNED_FIELDS
#:if defined('WITH_HIC')
    SELF%PINNED = INIT_PINNED_VALUE
#:endif
    IF(PRESENT(PINNED))THEN
      SELF%PINNED = PINNED
    ENDIF
    IF(PRESENT(POOLED))THEN
      SELF%POOLED = POOLED
    ENDIF

    SELF%MAP_DEVPTR = INIT_MAP_DEVPTR
    IF(PRESENT(MAP_DEVPTR))THEN
      SELF%MAP_DEVPTR = MAP_DEVPTR
    ENDIF
#:if not defined('WITH_HIC')
    IF(.NOT. SELF%MAP_DEVPTR)THEN
       CALL FIELD_ABORT ("${ftn}$_OWNER_INIT: CUDA backend needed to disable host-mapped device-pointer")
    ENDIF
#:endif

    IF (PRESENT (LBOUNDS)) THEN
      SELF%LBOUNDS=LBOUNDS
    ELSE
      SELF%LBOUNDS=1
    ENDIF

    SELF%UBOUNDS=UBOUNDS

    SELF%THREAD_BUFFER = .NOT. LLPERSISTENT

    IF (.NOT. LLPERSISTENT) THEN
      SELF%LBOUNDS(${ft.rank}$) = 1
      SELF%UBOUNDS(${ft.rank}$) = OML_MAX_THREADS ()
    ENDIF

    CALL SELF%SET_STATUS (UNINITIALIZED)
    IF (PRESENT(INIT_VALUE)) THEN
      SELF%HAS_INIT_VALUE=.TRUE.
      SELF%INIT_VALUE=INIT_VALUE
    ELSE IF(USE_INIT_DEBUG_VALUE) THEN
      SELF%HAS_INIT_VALUE=.TRUE.
      SELF%INIT_VALUE=INIT_DEBUG_VALUE_${ft.kind}$
    ENDIF
    IF(.NOT. IS_DELAYED) THEN
      CALL SELF%CREATE_HOST_DATA ()
    ENDIF

    SELF%COPY_FUNC => ${ftn}$_COPY_FUNC ()

  END SUBROUTINE ${ftn}$_OWNER_INIT

  SUBROUTINE ${ftn}$_OWNER_CREATE_HOST_DATA (SELF)
    ! Create FIELD object by explicitly allocating new data
    CLASS(${ftn}$_OWNER) :: SELF

    IF(SELF%POOLED)THEN
       CALL HOST_ALLOC_POOLED(SELF%PTR, SELF%LBOUNDS, SELF%UBOUNDS, SELF%BLKID)
    ELSE
       CALL HOST_ALLOC(SELF%PTR, SELF%LBOUNDS, SELF%UBOUNDS, SELF%PINNED)
    ENDIF
    CALL SELF%ADD_STATUS (UNINITIALIZED_CPU)
  END SUBROUTINE ${ftn}$_OWNER_CREATE_HOST_DATA

#:if ft.hasView
  FUNCTION ${ftn}$_GET_VIEW(SELF, BLOCK_INDEX, ZERO) RESULT(VIEW_PTR)

    USE FIELD_ABORT_MODULE
    USE FIELD_DEFAULTS_MODULE, ONLY: GET_VIEW_ABORT
$:offload_macros.runtime_api_import(indent=4)

    CLASS(${ftn}$) :: SELF
    ${ft.type}$, POINTER :: VIEW_PTR(${ft.viewShape}$)
    INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
    LOGICAL, OPTIONAL,  INTENT(IN) :: ZERO
    INTEGER(KIND=JPIM) :: IDX
    INTEGER(KIND=JPIM) :: LBOUNDS(${ft.rank}$)
    ${ft.type}$, POINTER :: ZPTR(${ft.shape}$)

!When the first thread reach this line it checks if the data are available on cpu.
!If not:
! - if GET_VIEW_ABORT is TRUE then GET_VIEW will abort the program
! - otherwise it then reachs a critical area, and check again in case another
!   thread has moved them meanwhile. And if they are still not, then they are moved.
    IF(.NOT. ASSOCIATED(SELF%PTR) &
        .OR. (SELF%IS_STATUS(NDEVFRESH) .AND. .NOT. SELF%IS_STATUS(NHSTFRESH)) &
    ) THEN
      IF(GET_VIEW_ABORT) THEN
        CALL FIELD_ABORT ("GET_VIEW WAS CALLED, BUT DATA IS NOT PRESENT ON HOST")
      ENDIF
!$omp critical
!Reinit GPU context for the local OpenMP thread
$:offload_macros.reinit_gpu_context(indent=6)
      IF(.NOT. ASSOCIATED(SELF%PTR) &
          .OR. (SELF%IS_STATUS(NDEVFRESH) .AND. .NOT. SELF%IS_STATUS(NHSTFRESH)) &
      ) THEN
        CALL SELF%GET_HOST_DATA(NWR, ZPTR)
      ENDIF
!$omp end critical
    ENDIF

    IDX = BLOCK_INDEX
    IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD ()

    LBOUNDS=SELF%LBOUNDS
    VIEW_PTR(${','.join('LBOUNDS(%d):'%(r+1) for r in range(ft.viewRank))}$) => SELF%PTR(${','.join(':' for _ in range(ft.viewRank))}$,IDX)

    IF (PRESENT(ZERO)) THEN
      IF (ZERO) VIEW_PTR(${ft.viewShape}$) = ${ft.default}$
    END IF
!$omp critical
    CALL SELF%REMOVE_STATUS(UNINITIALIZED_CPU)
    CALL SELF%SET_DEVICE_DIRTY()
!$omp end critical

  END FUNCTION ${ftn}$_GET_VIEW
#:endif

  SUBROUTINE ${ftn}$_DELETE_DEVICE_DATA(SELF)
    ! Delete the copy of this field on GPU device
    CLASS(${ftn}$) :: SELF

    IF (ASSOCIATED (SELF%DEVPTR)) THEN
      CALL DEV_DEALLOCATE (SELF%DEVPTR, SELF%MAP_DEVPTR)
    ENDIF
    CALL SELF%REMOVE_STATUS(NDEVFRESH)
    CALL SELF%ADD_STATUS(UNINITIALIZED_GPU)

  END SUBROUTINE ${ftn}$_DELETE_DEVICE_DATA

  SUBROUTINE ${ftn}$_FINAL(SELF)
    ! Finalizes field and deallocates owned data
    CLASS(${ftn}$) :: SELF
    NULLIFY(SELF%PTR)
    CALL SELF%DELETE_DEVICE_DATA()
  END SUBROUTINE ${ftn}$_FINAL

  SUBROUTINE ${ftn}$_WRAPPER_FINAL(SELF)
    ! Finalizes field and deallocates owned data
    CLASS(${ftn}$_WRAPPER) :: SELF
    ${ft.type}$, POINTER :: PTR(${ft.shape}$)
    IF (SELF%SYNC_ON_FINAL) THEN
      CALL SELF%GET_HOST_DATA_RDONLY(PTR)
    ENDIF
    CALL SELF%${ftn}$_FINAL
  END SUBROUTINE ${ftn}$_WRAPPER_FINAL

  SUBROUTINE ${ftn}$_OWNER_FINAL(SELF)
    ! Finalizes field and deallocates owned data
    CLASS(${ftn}$_OWNER) :: SELF

    IF(ASSOCIATED(SELF%PTR))THEN
       IF(SELF%POOLED)THEN
          CALL HOST_DEALLOC_POOLED (SELF%PTR, SELF%BLKID)
       ELSE
          CALL HOST_DEALLOC (SELF%PTR, SELF%PINNED)
       ENDIF
    ENDIF

    CALL SELF%${ftn}$_FINAL
  END SUBROUTINE ${ftn}$_OWNER_FINAL

  SUBROUTINE ${ftn}$_COPY_OBJECT (SELF, LDCREATED)

  USE FIELD_ABORT_MODULE

  CLASS(${ftn}$) :: SELF
  LOGICAL, INTENT (IN), OPTIONAL :: LDCREATED
  LOGICAL :: LLCREATED

  LLCREATED = .FALSE.
  IF (PRESENT (LDCREATED)) LLCREATED = LDCREATED

  IF (.NOT. LLCREATED) CALL FIELD_ABORT ('${ftn}$_COPY_OBJECT: OBJECT WAS NOT CREATED')

  IF (.NOT. SELF%LOBJECT_COPIED) THEN
    SELF%LOBJECT_COPIED = .TRUE.
#ifdef WITH_GPU_OFFLOAD
    IF (ASSOCIATED (SELF%DEVPTR)) THEN
$:offload_macros.attach(ptr=['SELF%DEVPTR'], indent=6)
    ENDIF
#endif
  ENDIF

  END SUBROUTINE ${ftn}$_COPY_OBJECT

  SUBROUTINE ${ftn}$_WIPE_OBJECT (SELF, LDDELETED)

  USE FIELD_ABORT_MODULE

  CLASS(${ftn}$) :: SELF
  LOGICAL, INTENT (IN), OPTIONAL :: LDDELETED
  LOGICAL :: LLDELETED

  LLDELETED = .FALSE.
  IF (PRESENT (LDDELETED)) LLDELETED = LDDELETED

  IF (.NOT. LLDELETED) CALL FIELD_ABORT ('${ftn}$_WIPE_OBJECT: OBJECT WAS NOT DELETED')

  IF (SELF%LOBJECT_COPIED) THEN
    SELF%LOBJECT_COPIED = .FALSE.
#ifdef WITH_GPU_OFFLOAD
    IF (ASSOCIATED (SELF%DEVPTR)) THEN
$:offload_macros.detach(ptr=['SELF%DEVPTR'], indent=6)
    ENDIF
#endif
  ENDIF

  END SUBROUTINE ${ftn}$_WIPE_OBJECT

  SUBROUTINE ${ftn}$_COPY_DATA (SELF, KDIR, QUEUE, BLK_BOUNDS)
  
  USE FIELD_ABORT_MODULE

  CLASS(${ftn}$) :: SELF
  INTEGER (KIND=JPIM),           INTENT(IN) :: KDIR
  INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN) :: QUEUE
  INTEGER(KIND=JPIM), OPTIONAL,  INTENT(IN) :: BLK_BOUNDS(2)
    
  INTEGER(KIND=JPIM) :: LB, UB
  ${ft.type}$, POINTER :: HST_BLK(${ft.shape}$) => NULL()
  REAL :: START, FINISH
  
  IF ( .NOT. PRESENT(BLK_BOUNDS) ) THEN
    CALL CPU_TIME(START)
    CALL SELF%COPY_FUNC (SELF%PTR, SELF%DEVPTR, SELF%MAP_DEVPTR, KDIR, QUEUE)
    CALL CPU_TIME(FINISH)
  ELSE
    LB = LBOUND(SELF%PTR, ${ft.rank}$)
    UB = UBOUND(SELF%PTR, ${ft.rank}$)
    IF ( BLK_BOUNDS(1) < LB .OR. BLK_BOUNDS(2) > UB ) THEN
      CALL FIELD_ABORT("BLOCK DIMENSIONS ARE OUT OF RANGE")
    END IF
    HST_BLK => SELF%PTR(${ft.hst_blk}$)
    CALL SELF%COPY_FUNC(HST_BLK, SELF%DEVPTR, SELF%MAP_DEVPTR, KDIR, QUEUE)
  END IF
  IF (KDIR == NH2D) THEN
    CALL SELF%STATS%INC_CPU_TO_GPU_TRANSFER(START, FINISH)
  ELSE IF (KDIR == ND2H) THEN
    CALL SELF%STATS%INC_GPU_TO_CPU_TRANSFER(START, FINISH)
  END IF

  END SUBROUTINE ${ftn}$_COPY_DATA

  SUBROUTINE ${ftn}$_GET_HOST_DATA (SELF, MODE, PTR, QUEUE, BLK_BOUNDS)
    USE FIELD_ASYNC_MODULE, ONLY: INIT_QUEUE
    CLASS(${ftn}$) :: SELF
    INTEGER (KIND=JPIM),           INTENT(IN)    :: MODE
    ${ft.type}$, POINTER,          INTENT(INOUT) :: PTR(${ft.shape}$)
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)     :: BLK_BOUNDS(2)

#:if defined('WITH_HIC')
    IF (PRESENT(QUEUE)) THEN
      CALL INIT_QUEUE(QUEUE)
    ENDIF
#:endif

    IF ((SELF%IS_STATUS(NDEVFRESH) .AND. .NOT. SELF%IS_STATUS(NHSTFRESH)) .OR. &
    &    SELF%IS_STATUS(UNDEFINED)) THEN
      CALL SELF%COPY_DATA (ND2H, QUEUE, BLK_BOUNDS=BLK_BOUNDS)
      CALL SELF%ADD_STATUS (NHSTFRESH)
      CALL SELF%REMOVE_STATUS (UNINITIALIZED_CPU)
    ENDIF

    CALL SELF%GET_HOST_POINTER(PTR, BLK_BOUNDS=BLK_BOUNDS)

    IF (IAND (MODE, NWR) /= 0) THEN
      CALL SELF%REMOVE_STATUS (UNINITIALIZED_CPU)
      CALL SELF%REMOVE_STATUS (NDEVFRESH)
      CALL SELF%ADD_STATUS (NHSTFRESH)
    ENDIF
  END SUBROUTINE ${ftn}$_GET_HOST_DATA

  SUBROUTINE ${ftn}$_GET_HOST_POINTER(SELF, PTR, BLK_BOUNDS)
    CLASS(${ftn}$) :: SELF
    ${ft.type}$, POINTER, INTENT(INOUT)         :: PTR(${ft.shape}$)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: BLK_BOUNDS(2)

    INTEGER(KIND=JPIM) :: LBOUNDS(${ft.rank}$)

    LBOUNDS=SELF%LBOUNDS
    IF ( PRESENT(BLK_BOUNDS) ) THEN
      PTR ( ${ft.lbptr_blk}$) => SELF%PTR (${ft.hst_blk}$)
    ELSE
      PTR (${ft.lbptr}$) => SELF%PTR (${','.join(':' for _ in range(ft.rank))}$)
    END IF
  END SUBROUTINE ${ftn}$_GET_HOST_POINTER

  SUBROUTINE ${ftn}$_OWNER_GET_HOST_DATA (SELF, MODE, PTR, QUEUE, BLK_BOUNDS)
    CLASS(${ftn}$_OWNER) :: SELF
    INTEGER (KIND=JPIM),           INTENT(IN)    :: MODE
    ${ft.type}$, POINTER,          INTENT(INOUT) :: PTR(${ft.shape}$)
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    INTEGER(KIND=JPIM), OPTIONAL,  INTENT(IN)    :: BLK_BOUNDS(2)

    IF(.NOT. ASSOCIATED(SELF%PTR))THEN
      CALL SELF%CREATE_HOST_DATA ()
    ENDIF

    IF (SELF%IS_STATUS(UNINITIALIZED) .AND. SELF%HAS_INIT_VALUE) THEN
      SELF%PTR=SELF%INIT_VALUE
      CALL SELF%REMOVE_STATUS (UNINITIALIZED_CPU)
      CALL SELF%ADD_STATUS (NHSTFRESH)
    ENDIF
    CALL SELF%${ftn}$_GET_HOST_DATA(MODE, PTR, QUEUE=QUEUE, BLK_BOUNDS=BLK_BOUNDS)

  END SUBROUTINE ${ftn}$_OWNER_GET_HOST_DATA

  SUBROUTINE ${ftn}$_GET_HOST_DATA_RDONLY (SELF, PPTR)
    CLASS(${ftn}$) :: SELF
    ${ft.type}$, POINTER,         INTENT(INOUT) :: PPTR(${ft.shape}$)

    CALL SELF%GET_HOST_DATA (NRD, PPTR)

  END SUBROUTINE ${ftn}$_GET_HOST_DATA_RDONLY

  SUBROUTINE ${ftn}$_SYNC_HOST_RDONLY (SELF)
    CLASS(${ftn}$) :: SELF
    ${ft.type}$, POINTER                        :: ZPTR(${ft.shape}$)

    CALL SELF%GET_HOST_DATA_RDONLY (ZPTR)

  END SUBROUTINE ${ftn}$_SYNC_HOST_RDONLY

  SUBROUTINE ${ftn}$_GET_HOST_DATA_RDWR (SELF, PPTR)
    CLASS(${ftn}$) :: SELF
    ${ft.type}$, POINTER,         INTENT(INOUT) :: PPTR(${ft.shape}$)

    CALL SELF%GET_HOST_DATA (IOR (NRD, NWR), PPTR)

  END SUBROUTINE ${ftn}$_GET_HOST_DATA_RDWR

  SUBROUTINE ${ftn}$_SYNC_HOST_RDWR (SELF)
    CLASS(${ftn}$) :: SELF
    ${ft.type}$, POINTER                        :: ZPTR(${ft.shape}$)

    CALL SELF%GET_HOST_DATA_RDWR (ZPTR)

  END SUBROUTINE ${ftn}$_SYNC_HOST_RDWR

  SUBROUTINE ${ftn}$_GET_HOST_DATA_FORCE (SELF, PPTR, QUEUE, BLK_BOUNDS)
    CLASS(${ftn}$) :: SELF
    ${ft.type}$, POINTER,         INTENT(INOUT) :: PPTR(${ft.shape}$)
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)   :: QUEUE
    INTEGER(KIND=JPIM),  OPTIONAL,  INTENT(IN)  :: BLK_BOUNDS(2)

    IF ( SELF%IS_STATUS(UNINITIALIZED) .OR. (.NOT. ASSOCIATED(SELF%DEVPTR)) ) THEN
      CALL SELF%SET_STATUS(NHSTFRESH)
    ELSE
      CALL SELF%SET_STATUS(UNDEFINED)
    END IF
    CALL SELF%GET_HOST_DATA (UNDEFINED, PPTR, QUEUE, BLK_BOUNDS=BLK_BOUNDS)
    CALL SELF%SET_STATUS(UNDEFINED)

  END SUBROUTINE ${ftn}$_GET_HOST_DATA_FORCE

  SUBROUTINE ${ftn}$_SYNC_HOST_FORCE (SELF, QUEUE, BLK_BOUNDS)
    CLASS(${ftn}$) :: SELF
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)   :: QUEUE
    INTEGER(KIND=JPIM),  OPTIONAL,  INTENT(IN)  :: BLK_BOUNDS(2)
    ${ft.type}$, POINTER                        :: ZPTR(${ft.shape}$)

    CALL SELF%GET_HOST_DATA_FORCE (ZPTR, QUEUE=QUEUE, BLK_BOUNDS=BLK_BOUNDS)

  END SUBROUTINE ${ftn}$_SYNC_HOST_FORCE

  SUBROUTINE ${ftn}$_CREATE_DEVICE_DATA (SELF, BLK_BOUNDS)
    CLASS(${ftn}$) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: BLK_BOUNDS(2)

    CALL DEV_ALLOCATE_DIM (DEV=SELF%DEVPTR, LBOUNDS=SELF%LBOUNDS, UBOUNDS=SELF%UBOUNDS, &
    &                      MAP_DEVPTR=SELF%MAP_DEVPTR, BLK_BOUNDS=BLK_BOUNDS)
    CALL SELF%ADD_STATUS(UNINITIALIZED_GPU)
  END SUBROUTINE

  SUBROUTINE ${ftn}$_GET_DEVICE_DATA (SELF, MODE, PTR, QUEUE, BLK_BOUNDS)
    USE FIELD_ASYNC_MODULE, ONLY: INIT_QUEUE
    CLASS(${ftn}$) :: SELF
    INTEGER (KIND=JPIM),           INTENT(IN)    :: MODE
    ${ft.type}$, POINTER,          INTENT(INOUT) :: PTR(${ft.shape}$)
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    INTEGER(KIND=JPIM), OPTIONAL,  INTENT(IN)    :: BLK_BOUNDS(2)

#:if defined('WITH_HIC')
    IF (PRESENT(QUEUE)) THEN
      CALL INIT_QUEUE(QUEUE)
    ENDIF
#:endif

    IF (.NOT. ASSOCIATED (SELF%DEVPTR)) THEN
      CALL SELF%CREATE_DEVICE_DATA(BLK_BOUNDS=BLK_BOUNDS)
    ENDIF
    IF ((.NOT. SELF%IS_STATUS(UNINITIALIZED_CPU) .AND. .NOT. SELF%IS_STATUS(NDEVFRESH)) .OR. &
    &    SELF%IS_STATUS(UNDEFINED)) THEN
      CALL SELF%COPY_DATA (NH2D, QUEUE, BLK_BOUNDS=BLK_BOUNDS)
      CALL SELF%ADD_STATUS (NDEVFRESH)
    ENDIF

    CALL SELF%GET_DEVICE_POINTER(PTR, BLK_BOUNDS=BLK_BOUNDS)

    IF (IAND (MODE, NWR) /= 0) THEN
      CALL SELF%REMOVE_STATUS (NHSTFRESH)
      CALL SELF%ADD_STATUS (NDEVFRESH)
    ENDIF
    CALL SELF%REMOVE_STATUS(UNINITIALIZED_GPU)

  END SUBROUTINE ${ftn}$_GET_DEVICE_DATA

  SUBROUTINE ${ftn}$_GET_DEVICE_POINTER (SELF, PTR, BLK_BOUNDS)
    CLASS(${ftn}$) :: SELF
    ${ft.type}$, POINTER,          INTENT(INOUT) :: PTR(${ft.shape}$)
    INTEGER(KIND=JPIM), OPTIONAL,  INTENT(IN)    :: BLK_BOUNDS(2)
    INTEGER(KIND=JPIM)                           :: LBOUNDS(${ft.rank}$)

    LBOUNDS=SELF%LBOUNDS
    IF ( PRESENT(BLK_BOUNDS) ) THEN
      PTR ( ${ft.lbptr_blk}$) => SELF%DEVPTR (${ft.devptr_blk}$)
    ELSE
      PTR (${ft.lbptr}$) => SELF%DEVPTR (${','.join(':' for _ in range(ft.rank))}$)
    END IF
  END SUBROUTINE ${ftn}$_GET_DEVICE_POINTER

#:if defined('WITH_FIAT')
  INTEGER*8 FUNCTION ${ftn}$_CRC64 (SELF) RESULT (ICRC)
    CLASS(${ftn}$) :: SELF
    ${ft.type}$, POINTER :: PTR(${ft.shape}$)
    ${ft.type}$, ALLOCATABLE :: ZZ(${ft.shape}$)
    INTEGER*8 :: ILEN
    EXTERNAL :: CRC64
    INTEGER(KIND=JPIM) :: ${','.join([f'J{i}'.upper() for i in range(1, ft.rank+1)])}$
    
    ICRC = 0   
 
    IF (IAND (SELF%GET_STATUS (), NHSTFRESH) /= 0) THEN
      CALL SELF%GET_HOST_DATA_RDONLY (PTR)
      ILEN = SIZE (PTR) * KIND (PTR)

      CALL CRC64 (PTR, ILEN, ICRC)
    ELSEIF (IAND (SELF%GET_STATUS (), NDEVFRESH) /= 0) THEN
      CALL SELF%GET_DEVICE_DATA_RDONLY (PTR)
      ALLOCATE (ZZ, MOLD=PTR)

#! OpenMP offload does not have an equivalent for the kernels command,
#! which means we cannot rely on array notation here and must generate
#! a nested gang-vector loop. 
#:for i in range(ft.rank, 0, -1)
#:set indent = ' ' * (5 + (ft.rank-i)*2)
#:if i == ft.rank
#:if i == 1
$:offload_macros.parallel_gang_vector_loop(present=['PTR',], copyout=['ZZ',])
#:else
$:offload_macros.parallel_gang_loop(present=['PTR',], copyout=['ZZ',])
#:endif
#:endif
#:if i == 1 and ft.rank > 1
$:offload_macros.parallel_vector_loop()
#:endif
${indent}$ DO ${f'J{i}'.upper()}$ = LBOUND(ZZ,${i}$), UBOUND(ZZ,${i}$)
#:endfor
${' ' * (ft.rank * 2 + 5)}$ ZZ(${','.join([f'J{i}'.upper() for i in range(1, ft.rank+1)])}$) = PTR(${','.join([f'J{i}'.upper() for i in range(1, ft.rank+1)])}$)
#:for i in range(1, ft.rank + 1)
#:set indent = ' ' * (5 + (ft.rank-i)*2)
${indent}$ ENDDO
#:endfor

      ILEN = SIZE (ZZ) * KIND (ZZ)
      CALL CRC64 (ZZ, ILEN, ICRC)
    ENDIF

  END FUNCTION
#:endif
  SUBROUTINE ${ftn}$_OWNER_GET_DEVICE_DATA (SELF, MODE, PTR, QUEUE, BLK_BOUNDS)
    CLASS(${ftn}$_OWNER) :: SELF
    INTEGER (KIND=JPIM),           INTENT(IN)    :: MODE
    ${ft.type}$, POINTER,          INTENT(INOUT) :: PTR(${ft.shape}$)
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)     :: BLK_BOUNDS(2)
#:for i in range(1, RANK+1)
    INTEGER(KIND=JPIM) :: I${i}$
#:endfor

    IF(.NOT. ASSOCIATED(SELF%DEVPTR))THEN
      CALL SELF%CREATE_DEVICE_DATA
    ENDIF
    IF (SELF%IS_STATUS(UNINITIALIZED) .AND. SELF%HAS_INIT_VALUE) THEN
$:offload_macros.parallel_gang_vector_loop(present=['SELF%DEVPTR'], copyin=['SELF'], collapse=RANK)
#:for i in range(1, RANK+1)
      DO I${i}$=SELF%LBOUNDS(${i}$), SELF%UBOUNDS(${i}$)
#:endfor
#:set array_indexes = ",".join("I" + str(i) for i in range(1, RANK+1))
      SELF%DEVPTR(${array_indexes}$)=SELF%INIT_VALUE
#:for i in range(1, RANK+1)
      ENDDO
#:endfor
      CALL SELF%ADD_STATUS(NDEVFRESH)
      CALL SELF%REMOVE_STATUS(UNINITIALIZED_GPU)
    ENDIF
    CALL SELF%${ftn}$_GET_DEVICE_DATA(MODE, PTR, QUEUE, BLK_BOUNDS=BLK_BOUNDS)

  END SUBROUTINE ${ftn}$_OWNER_GET_DEVICE_DATA

  SUBROUTINE ${ftn}$_GET_DEVICE_DATA_RDONLY (SELF, PPTR)
    CLASS(${ftn}$) :: SELF
    ${ft.type}$, POINTER,         INTENT(INOUT) :: PPTR(${ft.shape}$)

    CALL SELF%GET_DEVICE_DATA (NRD, PPTR)

  END SUBROUTINE ${ftn}$_GET_DEVICE_DATA_RDONLY

  SUBROUTINE ${ftn}$_GET_DEVICE_DATA_WRONLY (SELF, PPTR)
    CLASS(${ftn}$) :: SELF
    ${ft.type}$, POINTER,         INTENT(INOUT) :: PPTR(${ft.shape}$)

    CALL SELF%SET_STATUS (IOR (SELF%GET_STATUS (), NDEVFRESH))
    CALL SELF%GET_DEVICE_DATA (NWR, PPTR)

  END SUBROUTINE ${ftn}$_GET_DEVICE_DATA_WRONLY

  SUBROUTINE ${ftn}$_SYNC_DEVICE_WRONLY (SELF)
    CLASS(${ftn}$) :: SELF
    ${ft.type}$, POINTER :: PPTR(${ft.shape}$)

    CALL SELF%SET_STATUS (IOR (SELF%GET_STATUS (), NDEVFRESH))
    CALL SELF%GET_DEVICE_DATA (NWR, PPTR)

  END SUBROUTINE ${ftn}$_SYNC_DEVICE_WRONLY

  SUBROUTINE ${ftn}$_SYNC_DEVICE_RDONLY (SELF)
    CLASS(${ftn}$) :: SELF
    ${ft.type}$, POINTER                        :: ZPTR(${ft.shape}$)

    CALL SELF%GET_DEVICE_DATA_RDONLY (ZPTR)

  END SUBROUTINE ${ftn}$_SYNC_DEVICE_RDONLY

  SUBROUTINE ${ftn}$_GET_DEVICE_DATA_RDWR (SELF, PPTR)
    CLASS(${ftn}$) :: SELF
    ${ft.type}$, POINTER,         INTENT(INOUT) :: PPTR(${ft.shape}$)

    CALL SELF%GET_DEVICE_DATA (IOR (NRD, NWR), PPTR)

  END SUBROUTINE ${ftn}$_GET_DEVICE_DATA_RDWR

  SUBROUTINE ${ftn}$_GET_DEVICE_DATA_FORCE (SELF, PPTR, QUEUE, BLK_BOUNDS)
    CLASS(${ftn}$) :: SELF
    ${ft.type}$, POINTER,         INTENT(INOUT) :: PPTR(${ft.shape}$)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: BLK_BOUNDS(2)

    CALL SELF%SET_STATUS(UNDEFINED)
    CALL SELF%GET_DEVICE_DATA (UNDEFINED, PPTR, QUEUE, BLK_BOUNDS=BLK_BOUNDS)
    CALL SELF%SET_STATUS(UNDEFINED)

  END SUBROUTINE ${ftn}$_GET_DEVICE_DATA_FORCE

  SUBROUTINE ${ftn}$_SYNC_DEVICE_RDWR (SELF)
    CLASS(${ftn}$) :: SELF
    ${ft.type}$, POINTER                        :: ZPTR(${ft.shape}$)

    CALL SELF%GET_DEVICE_DATA_RDWR (ZPTR)

  END SUBROUTINE ${ftn}$_SYNC_DEVICE_RDWR

  SUBROUTINE ${ftn}$_SYNC_DEVICE_FORCE (SELF, QUEUE, BLK_BOUNDS)
    CLASS(${ftn}$) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: BLK_BOUNDS(2)
    ${ft.type}$, POINTER                        :: ZPTR(${ft.shape}$)

    CALL SELF%GET_DEVICE_DATA_FORCE (ZPTR, QUEUE=QUEUE, BLK_BOUNDS=BLK_BOUNDS)

  END SUBROUTINE ${ftn}$_SYNC_DEVICE_FORCE

  SUBROUTINE ${ftn}$_GET_DIMS (SELF, LBOUNDS, UBOUNDS)
    CLASS(${ftn}$), INTENT(IN) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: LBOUNDS(${ft.rank}$)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: UBOUNDS(${ft.rank}$)
    IF(PRESENT(LBOUNDS))THEN
      LBOUNDS=SELF%LBOUNDS
    ENDIF
    IF(PRESENT(UBOUNDS))THEN
      UBOUNDS=SELF%UBOUNDS
    ENDIF
  END SUBROUTINE ${ftn}$_GET_DIMS

  SUBROUTINE ${ftn}$_WRAPPER_RESIZE (SELF, UBOUNDS, LBOUNDS, PERSISTENT)

    USE FIELD_ABORT_MODULE

    CLASS(${ftn}$_WRAPPER),       INTENT(IN) :: SELF
    INTEGER(KIND=JPIM),           INTENT(IN) :: UBOUNDS(${ft.rank}$)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS(${ft.rank}$)
    LOGICAL, OPTIONAL,            INTENT(IN) :: PERSISTENT
    CALL FIELD_ABORT("RESIZE NOT IMPLMENTED FOR WRAPPER")
  END SUBROUTINE ${ftn}$_WRAPPER_RESIZE

  SUBROUTINE ${ftn}$_OWNER_RESIZE (SELF, UBOUNDS, LBOUNDS, PERSISTENT)
    CLASS(${ftn}$_OWNER),         INTENT(IN) :: SELF
    INTEGER(KIND=JPIM),           INTENT(IN) :: UBOUNDS(${ft.rank}$)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS(${ft.rank}$)
    LOGICAL, OPTIONAL,            INTENT(IN) :: PERSISTENT

    LOGICAL :: DELAYED
    ${ft.type}$ :: INIT_VALUE
    LOGICAL :: LLRESIZE
    INTEGER(KIND=JPIM) :: ILBOUND0(${ft.rank}$)
    INTEGER(KIND=JPIM) :: ILBOUNDS(${ft.rank}$)
    INTEGER(KIND=JPIM) :: IUBOUNDS(${ft.rank}$)

    ILBOUND0 = 1
    IF (PRESENT (LBOUNDS)) ILBOUND0 = LBOUNDS

    CALL SELF%GET_DIMS (LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS)

    LLRESIZE = ANY (UBOUNDS /= IUBOUNDS) .OR. ANY (ILBOUND0 /= ILBOUNDS)

    IF (LLRESIZE) THEN
      DELAYED=.NOT. ASSOCIATED(SELF%PTR)
      INIT_VALUE=SELF%INIT_VALUE
      CALL SELF%FINAL
      CALL SELF%INIT(UBOUNDS=UBOUNDS, LBOUNDS=LBOUNDS, PERSISTENT=PERSISTENT, DELAYED=DELAYED, INIT_VALUE=INIT_VALUE)
    ENDIF

  END SUBROUTINE ${ftn}$_OWNER_RESIZE

#ifdef __PGI
  SUBROUTINE ${ftn}$_SET_STATUS (SELF, KSTATUS)

  CLASS (${ftn}$) :: SELF
  INTEGER (KIND=JPIM), INTENT (IN) :: KSTATUS

  SELF%ISTATUS = KSTATUS

  END SUBROUTINE ${ftn}$_SET_STATUS
#endif

#:endfor

END MODULE FIELD_${RANK}$${SUFF}$_MODULE
