! (C) Copyright 2025- ECMWF.
! (C) Copyright 2025- Meteo-France.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

MODULE MEM_POOL_MODULE

   USE, INTRINSIC :: ISO_C_BINDING
   USE PARKIND1, ONLY : JPIM
   USE FIELD_DEFAULTS_MODULE
   IMPLICIT NONE

   TYPE, ABSTRACT :: MEM_BLOCK
     TYPE(C_PTR) :: DATA = C_NULL_PTR
     INTEGER(C_SIZE_T) :: POS = 0
     INTEGER(C_SIZE_T) :: SIZE = 0
     INTEGER :: NUMFLDS = 0

     CLASS(MEM_BLOCK), POINTER :: NEXT => NULL()
   
     CONTAINS
   
     PROCEDURE (MEM_BLOCK_DO_NOTHING), DEFERRED :: INIT
     PROCEDURE (MEM_BLOCK_DO_NOTHING), DEFERRED :: FINAL
     PROCEDURE :: ALLOC => MEM_BLOCK_ALLOC
     PROCEDURE :: DEALLOC => MEM_BLOCK_DEALLOC
   
   END TYPE MEM_BLOCK

   TYPE, EXTENDS (MEM_BLOCK) :: HOST_MEM_BLOCK
     LOGICAL :: LPINNED = .FALSE.

     CONTAINS

     PROCEDURE :: INIT => HOST_MEM_BLOCK_INIT
     PROCEDURE :: FINAL => HOST_MEM_BLOCK_FINAL
   END TYPE HOST_MEM_BLOCK

   TYPE, EXTENDS (MEM_BLOCK) :: DEVICE_MEM_BLOCK

     CONTAINS

     PROCEDURE :: INIT => DEVICE_MEM_BLOCK_INIT
     PROCEDURE :: FINAL => DEVICE_MEM_BLOCK_FINAL
   END TYPE DEVICE_MEM_BLOCK
   
   TYPE :: MEM_POOL
     CLASS(MEM_BLOCK), POINTER :: START_BLK => NULL()
     
     CONTAINS
   
     PROCEDURE :: ALLOC => MEM_POOL_ALLOC
     PROCEDURE :: DEALLOC => MEM_POOL_DEALLOC
     PROCEDURE :: REQUEST_MEM => MEM_POOL_REQUEST_MEM
     PROCEDURE :: REQUEST_FREE => MEM_POOL_REQUEST_FREE
     PROCEDURE :: FINAL => MEM_POOL_FINAL
     PROCEDURE, PRIVATE :: MEM_FREE => MEM_POOL_MEM_FREE
   
   END TYPE MEM_POOL

   ABSTRACT INTERFACE
      SUBROUTINE HST_MEM_BLK_INIT_METHOD(SIZE, DATA, LPINNED)
         IMPORT C_SIZE_T, C_PTR
         INTEGER(C_SIZE_T), INTENT(IN) :: SIZE
         TYPE(C_PTR), INTENT(OUT) :: DATA
         LOGICAL, INTENT(OUT) :: LPINNED
      END SUBROUTINE HST_MEM_BLK_INIT_METHOD
      SUBROUTINE HST_MEM_BLK_FINAL_METHOD(DATA, LPINNED)
         IMPORT C_PTR
         TYPE(C_PTR), INTENT(INOUT) :: DATA
         LOGICAL, INTENT(IN) :: LPINNED
      END SUBROUTINE HST_MEM_BLK_FINAL_METHOD
      SUBROUTINE DEV_MEM_BLK_INIT_METHOD(SIZE, DATA)
         IMPORT C_SIZE_T, C_PTR
         INTEGER(C_SIZE_T), INTENT(IN) :: SIZE
         TYPE(C_PTR), INTENT(OUT) :: DATA
      END SUBROUTINE DEV_MEM_BLK_INIT_METHOD
      SUBROUTINE DEV_MEM_BLK_FINAL_METHOD(DATA)
         IMPORT C_PTR
         TYPE(C_PTR), INTENT(INOUT) :: DATA
      END SUBROUTINE DEV_MEM_BLK_FINAL_METHOD
      SUBROUTINE MEM_BLOCK_DO_NOTHING( SELF )
         IMPORT MEM_BLOCK
         CLASS(MEM_BLOCK) :: SELF
      END SUBROUTINE MEM_BLOCK_DO_NOTHING
   END INTERFACE

   INTERFACE
      SUBROUTINE C_PTR_INCR (SIZ, PTR, DATA) BIND (C, NAME='c_ptr_incr')
        IMPORT :: C_PTR, C_SIZE_T
        INTEGER (C_SIZE_T), VALUE, INTENT(IN) :: SIZ
        TYPE (C_PTR), INTENT(IN) :: PTR
        TYPE (C_PTR), INTENT(OUT) :: DATA
      END SUBROUTINE C_PTR_INCR
   END INTERFACE

   PROCEDURE(HST_MEM_BLK_INIT_METHOD), POINTER :: HST_MEM_BLK_INIT => NULL()
   PROCEDURE(HST_MEM_BLK_FINAL_METHOD), POINTER :: HST_MEM_BLK_FINAL => NULL()
   PROCEDURE(DEV_MEM_BLK_INIT_METHOD), POINTER :: DEV_MEM_BLK_INIT => NULL()
   PROCEDURE(DEV_MEM_BLK_FINAL_METHOD), POINTER :: DEV_MEM_BLK_FINAL => NULL()
   
   PRIVATE

   PUBLIC :: MEM_POOL
   PUBLIC :: HOST_MEM_BLOCK
   PUBLIC :: DEVICE_MEM_BLOCK
   PUBLIC :: HST_MEM_BLK_INIT
   PUBLIC :: HST_MEM_BLK_FINAL
   PUBLIC :: DEV_MEM_BLK_INIT
   PUBLIC :: DEV_MEM_BLK_FINAL

   CONTAINS

      SUBROUTINE HOST_MEM_BLOCK_INIT( SELF )
         CLASS(HOST_MEM_BLOCK) :: SELF
      
         CALL HST_MEM_BLK_INIT(SELF%SIZE, SELF%DATA, SELF%LPINNED)
      
      END SUBROUTINE HOST_MEM_BLOCK_INIT

      SUBROUTINE DEVICE_MEM_BLOCK_INIT( SELF )
         CLASS(DEVICE_MEM_BLOCK) :: SELF
      
         CALL DEV_MEM_BLK_INIT(SELF%SIZE, SELF%DATA)
      
      END SUBROUTINE DEVICE_MEM_BLOCK_INIT
      
      SUBROUTINE MEM_BLOCK_ALLOC( SELF, ALLOC_SIZE, DATA )
         CLASS(MEM_BLOCK) :: SELF
         INTEGER(C_SIZE_T), INTENT(IN) :: ALLOC_SIZE
         TYPE(C_PTR), INTENT(OUT) :: DATA
      
         CALL C_PTR_INCR(SELF%POS, SELF%DATA, DATA)
         SELF%POS = SELF%POS + ALLOC_SIZE
      
         SELF%NUMFLDS = SELF%NUMFLDS + 1
      
      END SUBROUTINE MEM_BLOCK_ALLOC
      
      SUBROUTINE MEM_BLOCK_DEALLOC( SELF )
         CLASS(MEM_BLOCK) :: SELF
      
         SELF%NUMFLDS = SELF%NUMFLDS - 1
         IF( SELF%NUMFLDS == 0 ) SELF%POS = 0
      
      END SUBROUTINE MEM_BLOCK_DEALLOC
      
      SUBROUTINE HOST_MEM_BLOCK_FINAL( SELF )
         CLASS(HOST_MEM_BLOCK) :: SELF
      
         IF( .NOT. SELF%NUMFLDS == 0 )THEN
            PRINT *, "FIELD_API DETECTED UNFINALISED FIELDS, POTENTIAL HOST MEMORY LEAK"
         ENDIF
      
         CALL HST_MEM_BLK_FINAL(SELF%DATA, SELF%LPINNED)

         SELF%SIZE = 0
         SELF%POS = 0
         SELF%NUMFLDS = 0
      END SUBROUTINE HOST_MEM_BLOCK_FINAL

      SUBROUTINE DEVICE_MEM_BLOCK_FINAL( SELF )
         CLASS(DEVICE_MEM_BLOCK) :: SELF
      
         IF( .NOT. SELF%NUMFLDS == 0 )THEN
            PRINT *, "FIELD_API DETECTED UNFINALISED FIELDS, POTENTIAL DEVICE MEMORY LEAK"
         ENDIF
      
         CALL DEV_MEM_BLK_FINAL(SELF%DATA)

         SELF%SIZE = 0
         SELF%POS = 0
         SELF%NUMFLDS = 0
      END SUBROUTINE DEVICE_MEM_BLOCK_FINAL
      
      SUBROUTINE MEM_POOL_FINAL( SELF )
         CLASS(MEM_POOL) :: SELF
      
         IF( ASSOCIATED(SELF%START_BLK) ) CALL SELF%MEM_FREE(SELF%START_BLK)
      END SUBROUTINE MEM_POOL_FINAL
      
      SUBROUTINE MEM_POOL_MEM_FREE(SELF, BLK)
         CLASS(MEM_POOL) :: SELF
         CLASS(MEM_BLOCK), POINTER, INTENT(INOUT) :: BLK
      
         IF( ASSOCIATED(BLK%NEXT) ) CALL SELF%MEM_FREE(BLK%NEXT)
         CALL BLK%FINAL()
         DEALLOCATE(BLK)
         NULLIFY(BLK)
      END SUBROUTINE MEM_POOL_MEM_FREE
      
      SUBROUTINE MEM_POOL_ALLOC( SELF, ARR_SIZE, BLKID, DATA )
         CLASS(MEM_POOL) :: SELF
         INTEGER(C_SIZE_T), INTENT(IN) :: ARR_SIZE
         INTEGER(KIND=JPIM), INTENT(INOUT) :: BLKID
         TYPE(C_PTR), INTENT(OUT) :: DATA
         INTEGER(C_SIZE_T) :: ALLOC_SIZE
      
         ALLOC_SIZE = ARR_SIZE + MOD(ARR_SIZE, POOL_ALLOC_PADDING_FACTOR)
      
         CALL SELF%REQUEST_MEM( ALLOC_SIZE, SELF%START_BLK, DATA, BLKID )
      
      END SUBROUTINE MEM_POOL_ALLOC
      
      SUBROUTINE MEM_POOL_DEALLOC( SELF, FIELD_BLKID )
         CLASS(MEM_POOL) :: SELF
         INTEGER(KIND=JPIM), INTENT(IN) :: FIELD_BLKID
         INTEGER(KIND=JPIM) :: BLKID
      
         BLKID = 1
         CALL SELF%REQUEST_FREE( FIELD_BLKID, SELF%START_BLK, BLKID )
      END SUBROUTINE MEM_POOL_DEALLOC
      
      SUBROUTINE MEM_POOL_REQUEST_FREE( SELF, FIELD_BLKID, BLK, BLKID )
         CLASS(MEM_POOL) :: SELF
         INTEGER(KIND=JPIM), INTENT(IN) :: FIELD_BLKID
         CLASS(MEM_BLOCK), POINTER, INTENT(INOUT) :: BLK
         INTEGER(KIND=JPIM), INTENT(INOUT) :: BLKID
      
         IF( FIELD_BLKID == BLKID )THEN
            CALL BLK%DEALLOC()
         ELSE
            BLKID = BLKID + 1
            CALL SELF%REQUEST_FREE(FIELD_BLKID, BLK%NEXT, BLKID)
         ENDIF
      
      END SUBROUTINE MEM_POOL_REQUEST_FREE
      
      SUBROUTINE MEM_POOL_REQUEST_MEM( SELF, ALLOC_SIZE, BLK, DATA, BLKID )
         CLASS(MEM_POOL) :: SELF
         INTEGER(C_SIZE_T), INTENT(IN) :: ALLOC_SIZE
         CLASS(MEM_BLOCK), POINTER, INTENT(INOUT) :: BLK
         TYPE(C_PTR), INTENT(OUT) :: DATA
         INTEGER(KIND=JPIM), INTENT(INOUT) :: BLKID
      
         BLKID = BLKID + 1
      
         IF( C_ASSOCIATED(BLK%DATA) )THEN
            IF( BLK%POS + ALLOC_SIZE <= BLK%SIZE ) THEN
               !... Allocation can fit within existing block
               CALL BLK%ALLOC(ALLOC_SIZE, DATA)
            ELSE
               !... Proceed to next block
               IF( .NOT. ASSOCIATED(BLK%NEXT) ) THEN
                 SELECT TYPE(BLK)
                    TYPE IS (HOST_MEM_BLOCK)
                       ALLOCATE(HOST_MEM_BLOCK::BLK%NEXT)
                    TYPE IS (DEVICE_MEM_BLOCK)
                       ALLOCATE(DEVICE_MEM_BLOCK::BLK%NEXT)
                 END SELECT
               ENDIF
               CALL SELF%REQUEST_MEM(ALLOC_SIZE, BLK%NEXT, DATA, BLKID)
            ENDIF
         ELSE
           !... Create new block
           BLK%SIZE = POOL_BLOCK_SIZE
           DO WHILE ( BLK%SIZE < ALLOC_SIZE )
              BLK%SIZE = BLK%SIZE*2
           ENDDO
           CALL BLK%INIT()
           CALL BLK%ALLOC(ALLOC_SIZE, DATA)
         ENDIF
      
      END SUBROUTINE MEM_POOL_REQUEST_MEM

END MODULE MEM_POOL_MODULE
