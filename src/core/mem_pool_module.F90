! (C) Copyright 2025- ECMWF.
! (C) Copyright 2025- Meteo-France.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

MODULE MEM_POOL_MODULE

   USE, INTRINSIC :: ISO_C_BINDING
   USE PARKIND1, ONLY : JPIM
   USE FIELD_DEFAULTS_MODULE
   IMPLICIT NONE

   TYPE :: MEM_BLOCK
     TYPE(C_PTR) :: DATA = C_NULL_PTR
     INTEGER(C_SIZE_T) :: POS = 0
     INTEGER(C_SIZE_T) :: SIZE = 0
     INTEGER :: NUMFLDS = 0
   
     TYPE(MEM_BLOCK), POINTER :: NEXT => NULL()
   
     CONTAINS
   
     PROCEDURE :: INIT => MEM_BLOCK_INIT
     PROCEDURE :: FINAL => MEM_BLOCK_FINAL
     PROCEDURE :: ALLOC => MEM_BLOCK_ALLOC
     PROCEDURE :: DEALLOC => MEM_BLOCK_DEALLOC
   
   END TYPE MEM_BLOCK
   
   TYPE :: MEM_POOL
     TYPE(MEM_BLOCK), POINTER :: START_BLK => NULL()
     
     CONTAINS
   
     PROCEDURE :: ALLOC => MEM_POOL_ALLOC
     PROCEDURE :: DEALLOC => MEM_POOL_DEALLOC
     PROCEDURE :: REQUEST_MEM => MEM_POOL_REQUEST_MEM
     PROCEDURE :: REQUEST_FREE => MEM_POOL_REQUEST_FREE
     PROCEDURE :: FINAL => MEM_POOL_FINAL
     PROCEDURE, PRIVATE :: MEM_FREE => MEM_POOL_MEM_FREE
   
   END TYPE MEM_POOL

   ABSTRACT INTERFACE
      SUBROUTINE MEM_BLK_INIT_METHOD(SIZE, DATA)
         IMPORT C_SIZE_T, C_PTR
         INTEGER(C_SIZE_T), INTENT(IN) :: SIZE
         TYPE(C_PTR), INTENT(OUT) :: DATA
      END SUBROUTINE MEM_BLK_INIT_METHOD
      SUBROUTINE MEM_BLK_FINAL_METHOD(DATA)
         IMPORT C_PTR
         TYPE(C_PTR), INTENT(INOUT) :: DATA
      END SUBROUTINE MEM_BLK_FINAL_METHOD
   END INTERFACE

   INTERFACE
      SUBROUTINE C_PTR_INCR (SIZ, PTR, DATA) BIND (C, NAME='c_ptr_incr')
        IMPORT :: C_PTR, C_SIZE_T
        INTEGER (C_SIZE_T), VALUE, INTENT(IN) :: SIZ
        TYPE (C_PTR), INTENT(IN) :: PTR
        TYPE (C_PTR), INTENT(OUT) :: DATA
      END SUBROUTINE C_PTR_INCR
   END INTERFACE

   PROCEDURE(MEM_BLK_INIT_METHOD), POINTER :: MEM_BLK_INIT => NULL()
   PROCEDURE(MEM_BLK_FINAL_METHOD), POINTER :: MEM_BLK_FINAL => NULL()
   
   PRIVATE

   PUBLIC :: MEM_POOL
   PUBLIC :: MEM_BLK_INIT_METHOD
   PUBLIC :: MEM_BLK_FINAL_METHOD

   CONTAINS

      SUBROUTINE MEM_BLOCK_INIT( SELF )
         CLASS(MEM_BLOCK) :: SELF
      
         CALL MEM_BLK_INIT(SELF%SIZE, SELF%DATA)
      
      END SUBROUTINE MEM_BLOCK_INIT
      
      SUBROUTINE MEM_BLOCK_ALLOC( SELF, ALLOC_SIZE, DATA )
         CLASS(MEM_BLOCK) :: SELF
         INTEGER(C_SIZE_T), INTENT(IN) :: ALLOC_SIZE
         TYPE(C_PTR), INTENT(OUT) :: DATA
      
         CALL C_PTR_INCR(SELF%POS, SELF%DATA, DATA)
         SELF%POS = SELF%POS + ALLOC_SIZE
      
         SELF%NUMFLDS = SELF%NUMFLDS + 1
      
      END SUBROUTINE MEM_BLOCK_ALLOC
      
      SUBROUTINE MEM_BLOCK_DEALLOC( SELF )
         CLASS(MEM_BLOCK) :: SELF
      
         SELF%NUMFLDS = SELF%NUMFLDS - 1
         IF( SELF%NUMFLDS == 0 ) SELF%POS = 0
      
      END SUBROUTINE MEM_BLOCK_DEALLOC
      
      SUBROUTINE MEM_BLOCK_FINAL( SELF )
         CLASS(MEM_BLOCK) :: SELF
      
         IF( .NOT. SELF%NUMFLDS == 0 )THEN
            PRINT *, "FIELD_API DETECTED UNFINALISED FIELDS, POTENTIAL DEVICE MEMORY LEAK"
         ENDIF
      
         CALL MEM_BLK_FINAL(SELF%DATA)

         SELF%SIZE = 0
         SELF%POS = 0
         SELF%NUMFLDS = 0
      END SUBROUTINE MEM_BLOCK_FINAL
      
      SUBROUTINE MEM_POOL_FINAL( SELF )
         CLASS(MEM_POOL) :: SELF
      
         IF( ASSOCIATED(SELF%START_BLK) ) CALL SELF%MEM_FREE(SELF%START_BLK)
      END SUBROUTINE MEM_POOL_FINAL
      
      SUBROUTINE MEM_POOL_MEM_FREE(SELF, BLK)
         CLASS(MEM_POOL) :: SELF
         TYPE(MEM_BLOCK), POINTER, INTENT(INOUT) :: BLK
      
         IF( ASSOCIATED(BLK%NEXT) ) CALL SELF%MEM_FREE(BLK%NEXT)
         CALL BLK%FINAL()
         DEALLOCATE(BLK)
         NULLIFY(BLK)
      END SUBROUTINE MEM_POOL_MEM_FREE
      
      SUBROUTINE MEM_POOL_ALLOC( SELF, ARR_SIZE, BLKID, DATA, BLK_INIT, BLK_FINAL )
         CLASS(MEM_POOL) :: SELF
         INTEGER(C_SIZE_T), INTENT(IN) :: ARR_SIZE
         INTEGER(KIND=JPIM), INTENT(INOUT) :: BLKID
         TYPE(C_PTR), INTENT(OUT) :: DATA
         PROCEDURE(MEM_BLK_INIT_METHOD), POINTER, INTENT(IN) :: BLK_INIT
         PROCEDURE(MEM_BLK_FINAL_METHOD), POINTER, INTENT(IN) :: BLK_FINAL
         INTEGER(C_SIZE_T) :: ALLOC_SIZE
         CHARACTER(LEN=20) :: HOST_POOL_BLOCK_SIZE
         INTEGER(C_SIZE_T) :: HOST_POOL_BLOCK_SIZE_INT
         INTEGER :: STAT
      
         ALLOC_SIZE = ARR_SIZE + MOD(ARR_SIZE, POOL_ALLOC_PADDING_FACTOR)
      
         IF ( .NOT. ASSOCIATED(SELF%START_BLK) ) THEN
            ALLOCATE(SELF%START_BLK)
            CALL GET_ENVIRONMENT_VARIABLE('FIELD_API_HOST_POOL_BLOCK_SIZE', HOST_POOL_BLOCK_SIZE, STATUS=STAT)
            IF (STAT == 0) THEN
               HOST_POOL_BLOCK_SIZE = TRIM(HOST_POOL_BLOCK_SIZE)
               READ(HOST_POOL_BLOCK_SIZE, *) HOST_POOL_BLOCK_SIZE_INT
               IF (HOST_POOL_BLOCK_SIZE_INT > 0) POOL_BLOCK_SIZE = HOST_POOL_BLOCK_SIZE_INT
            ENDIF
         ENDIF

         IF ( .NOT. ASSOCIATED(MEM_BLK_INIT) ) MEM_BLK_INIT => BLK_INIT
         IF ( .NOT. ASSOCIATED(MEM_BLK_FINAL) ) MEM_BLK_FINAL => BLK_FINAL

         CALL SELF%REQUEST_MEM( ALLOC_SIZE, SELF%START_BLK, DATA, BLKID )
      
      END SUBROUTINE MEM_POOL_ALLOC
      
      SUBROUTINE MEM_POOL_DEALLOC( SELF, FIELD_BLKID )
         CLASS(MEM_POOL) :: SELF
         INTEGER(KIND=JPIM), INTENT(IN) :: FIELD_BLKID
         INTEGER(KIND=JPIM) :: BLKID
      
         BLKID = 1
         CALL SELF%REQUEST_FREE( FIELD_BLKID, SELF%START_BLK, BLKID )
      END SUBROUTINE MEM_POOL_DEALLOC
      
      SUBROUTINE MEM_POOL_REQUEST_FREE( SELF, FIELD_BLKID, BLK, BLKID )
         CLASS(MEM_POOL) :: SELF
         INTEGER(KIND=JPIM), INTENT(IN) :: FIELD_BLKID
         TYPE(MEM_BLOCK), POINTER, INTENT(INOUT) :: BLK
         INTEGER(KIND=JPIM), INTENT(INOUT) :: BLKID
      
         IF( FIELD_BLKID == BLKID )THEN
            CALL BLK%DEALLOC()
         ELSE
            BLKID = BLKID + 1
            CALL SELF%REQUEST_FREE(FIELD_BLKID, BLK%NEXT, BLKID)
         ENDIF
      
      END SUBROUTINE MEM_POOL_REQUEST_FREE
      
      SUBROUTINE MEM_POOL_REQUEST_MEM( SELF, ALLOC_SIZE, BLK, DATA, BLKID )
         CLASS(MEM_POOL) :: SELF
         INTEGER(C_SIZE_T), INTENT(IN) :: ALLOC_SIZE
         TYPE(MEM_BLOCK), POINTER, INTENT(INOUT) :: BLK
         TYPE(C_PTR), INTENT(OUT) :: DATA
         INTEGER(KIND=JPIM), INTENT(INOUT) :: BLKID
      
         BLKID = BLKID + 1
      
         IF( C_ASSOCIATED(BLK%DATA) )THEN
            IF( BLK%POS + ALLOC_SIZE <= BLK%SIZE ) THEN
               !... Allocation can fit within existing block
               CALL BLK%ALLOC(ALLOC_SIZE, DATA)
            ELSE
               !... Proceed to next block
               IF( .NOT. ASSOCIATED(BLK%NEXT) ) ALLOCATE(BLK%NEXT)
               CALL SELF%REQUEST_MEM(ALLOC_SIZE, BLK%NEXT, DATA, BLKID)
            ENDIF
         ELSE
           !... Create new block
           BLK%SIZE = POOL_BLOCK_SIZE
           DO WHILE ( BLK%SIZE < ALLOC_SIZE )
              BLK%SIZE = BLK%SIZE*2
           ENDDO
           CALL BLK%INIT()
           CALL BLK%ALLOC(ALLOC_SIZE, DATA)
         ENDIF
      
      END SUBROUTINE MEM_POOL_REQUEST_MEM

END MODULE MEM_POOL_MODULE
