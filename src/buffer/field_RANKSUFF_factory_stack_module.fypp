#! (C) Copyright 2022- ECMWF.
#! (C) Copyright 2022- Meteo-France.
#!
#! This software is licensed under the terms of the Apache Licence Version 2.0
#! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
#! In applying this licence, ECMWF does not waive the privileges and immunities
#! granted to it by virtue of its status as an intergovernmental organisation
#! nor does it submit to any jurisdiction.

SUBMODULE(FIELD_${RANK}$${SUFF}$_FACTORY_MODULE) FIELD_${RANK}$${SUFF}$_FACTORY_STACK_MODULE

#:set fieldTypeList = fieldType.getFieldTypeList (ranks=[RANK], kinds=['JP' + SUFF])

USE FIELD_BASIC_MODULE
#:for ft in fieldTypeList
USE ${ft.name}$_MODULE
#:if defined('HAVE_GANG')
#:if ft.hasView
USE FIELD_${ft.rank-1}$${SUFF}$_MODULE
USE ${ft.name}$_STACK_MODULE
#:endif
#:endif
#:endfor

${fieldType.useParkind1 ()}$

IMPLICIT NONE

CONTAINS

#:for ft in fieldTypeList
#:if ft.hasView
MODULE SUBROUTINE ${ft.name}$_NEW_STACK_WRAPPER (FIELD_PTR, DATA, LSTACK, LBOUNDS, PERSISTENT, SYNC_ON_FINAL, INITIALIZED, &
&                                                MEMBER_LBOUNDS, MEMBER_MAP, MEMBER_RANKS)

USE FIELD_STATISTICS_MODULE
USE FIELD_ABORT_MODULE

CLASS(${ft.name}$), POINTER :: FIELD_PTR
${ft.type}$, TARGET, INTENT (IN) :: DATA (${ft.shape}$)
LOGICAL,  INTENT(IN) :: LSTACK
INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS (${ft.rank}$)
LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
LOGICAL, OPTIONAL,  INTENT(IN) :: SYNC_ON_FINAL
LOGICAL, OPTIONAL,  INTENT(IN) :: INITIALIZED

INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: MEMBER_LBOUNDS(:)
INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: MEMBER_MAP(:)
INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: MEMBER_RANKS(:)

TYPE(${ft.name}$_STACK_WRAPPER), POINTER :: FIELD_STACK
INTEGER (KIND=JPIM) :: JFLD, IFLD

#:if ft.rank > 2
#:set member_dim = ft.rank - 1
#:else
#:set member_dim = ft.rank
#:endif

IF (.NOT. LSTACK) THEN
  CALL FIELD_ABORT('${ft.name}_STACK_WRAPPER: CANNOT INITIALIZE FIELD_STACK WITH LSTACK=.FALSE.')
ENDIF

ALLOCATE (FIELD_STACK)

IF (PRESENT(MEMBER_MAP)) THEN
  FIELD_STACK%MEMBER_MAP = MEMBER_MAP
ELSE
!... Assume each entry in ${member_dim}$ corresponds to a separate member
  ALLOCATE(FIELD_STACK%MEMBER_MAP(SIZE(DATA, ${member_dim}$) * 2))
  DO JFLD=1,SIZE(FIELD_STACK%MEMBER_MAP),2
    FIELD_STACK%MEMBER_MAP(JFLD) = JFLD
    FIELD_STACK%MEMBER_MAP(JFLD + 1) = JFLD
  ENDDO
ENDIF

IF (PRESENT(MEMBER_RANKS)) THEN
  FIELD_STACK%MEMBER_RANKS = MEMBER_RANKS
ELSE
  ALLOCATE(FIELD_STACK%MEMBER_RANKS(SIZE(FIELD_STACK%MEMBER_MAP)/2))
  DO JFLD=1, SIZE(FIELD_STACK%MEMBER_MAP), 2
     IFLD = (JFLD - 1)/2 + 1
     IF(FIELD_STACK%MEMBER_MAP(JFLD) == FIELD_STACK%MEMBER_MAP(JFLD+1)) THEN
        FIELD_STACK%MEMBER_RANKS(IFLD) = ${ft.rank - 1}$
     ELSE
        FIELD_STACK%MEMBER_RANKS(IFLD) = ${ft.rank}$
     ENDIF
  ENDDO
ENDIF

IF (PRESENT(MEMBER_LBOUNDS)) THEN
  FIELD_STACK%MEMBER_LBOUNDS = MEMBER_LBOUNDS
ELSE
  ALLOCATE(FIELD_STACK%MEMBER_LBOUNDS(SIZE(FIELD_STACK%MEMBER_MAP)/2))
ENDIF

CALL FIELD_STACK%INIT (DATA, LBOUNDS=LBOUNDS, PERSISTENT=PERSISTENT, &
&                      SYNC_ON_FINAL=SYNC_ON_FINAL, INITIALIZED=INITIALIZED)


FIELD_PTR => FIELD_STACK

IF (FIELD_STATISTICS_ENABLE) CALL FIELD_STATISTICS_NEW ()

END SUBROUTINE

MODULE SUBROUTINE ${ft.name}$_NEW_STACK_OWNER (FIELD_PTR, UBOUNDS, LSTACK, LBOUNDS, PERSISTENT, DELAYED, INIT_VALUE, &
&                                              MEMBER_LBOUNDS, MEMBER_MAP, MEMBER_RANKS)

USE FIELD_STATISTICS_MODULE
USE FIELD_ABORT_MODULE

CLASS(${ft.name}$), POINTER :: FIELD_PTR
INTEGER(KIND=JPIM), INTENT(IN) :: UBOUNDS (${ft.rank}$)
LOGICAL,  INTENT(IN) :: LSTACK
INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS (${ft.rank}$)
LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
LOGICAL, OPTIONAL,  INTENT(IN) :: DELAYED
${ft.type}$, OPTIONAL, INTENT(IN) :: INIT_VALUE

INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: MEMBER_LBOUNDS(:)
INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: MEMBER_MAP(:)
INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: MEMBER_RANKS(:)

TYPE(${ft.name}$_STACK_OWNER), POINTER :: FIELD_STACK
INTEGER (KIND=JPIM) :: JFLD, IFLD
INTEGER (KIND=JPIM) :: LLBOUNDS(${ft.rank}$)

IF (.NOT. LSTACK) THEN
  CALL FIELD_ABORT('${ft.name}_STACK_OWNER: CANNOT INITIALIZE FIELD_STACK WITH LSTACK=.FALSE.')
ENDIF
ALLOCATE (FIELD_STACK)

LLBOUNDS = 1
IF (PRESENT(LBOUNDS)) LLBOUNDS = LBOUNDS

IF (PRESENT(MEMBER_MAP)) THEN
  FIELD_STACK%MEMBER_MAP = MEMBER_MAP
ELSE
!... Assume each entry in ${member_dim}$ corresponds to a separate member
  ALLOCATE(FIELD_STACK%MEMBER_MAP((UBOUNDS(${member_dim}$) - LLBOUNDS(${member_dim}$) + 1) * 2))
  DO JFLD=1,SIZE(FIELD_STACK%MEMBER_MAP),2
    FIELD_STACK%MEMBER_MAP(JFLD) = JFLD
    FIELD_STACK%MEMBER_MAP(JFLD + 1) = JFLD
  ENDDO
ENDIF

IF (PRESENT(MEMBER_RANKS)) THEN
  FIELD_STACK%MEMBER_RANKS = MEMBER_RANKS
ELSE
  ALLOCATE(FIELD_STACK%MEMBER_RANKS(SIZE(FIELD_STACK%MEMBER_MAP)/2))
  DO JFLD=1, SIZE(FIELD_STACK%MEMBER_MAP), 2
     IFLD = (JFLD - 1)/2 + 1
     IF(FIELD_STACK%MEMBER_MAP(JFLD) == FIELD_STACK%MEMBER_MAP(JFLD+1)) THEN
        FIELD_STACK%MEMBER_RANKS(IFLD) = ${ft.rank - 1}$
     ELSE
        FIELD_STACK%MEMBER_RANKS(IFLD) = ${ft.rank}$
     ENDIF
  ENDDO
ENDIF

IF (PRESENT(MEMBER_LBOUNDS)) THEN
  FIELD_STACK%MEMBER_LBOUNDS = MEMBER_LBOUNDS
ELSE
  ALLOCATE(FIELD_STACK%MEMBER_LBOUNDS(SIZE(FIELD_STACK%MEMBER_MAP)/2))
ENDIF

CALL FIELD_STACK%INIT (LBOUNDS=LBOUNDS, UBOUNDS=UBOUNDS, PERSISTENT=PERSISTENT, DELAYED=DELAYED, INIT_VALUE=INIT_VALUE)

FIELD_PTR => FIELD_STACK

IF (FIELD_STATISTICS_ENABLE) CALL FIELD_STATISTICS_NEW ()

END SUBROUTINE

MODULE SUBROUTINE ${ft.name}$_GET_STACK_MEMBER_0(SELF, IDX, MEMBER)
  CLASS(${ft.name}$), INTENT(IN) :: SELF
  INTEGER(KIND=JPIM), INTENT(IN) :: IDX
  CLASS(FIELD_${RANK-1}$${SUFF}$), POINTER, INTENT(INOUT) :: MEMBER

  SELECT TYPE(SELF)
  CLASS IS(${ft.name}$_STACK_OWNER)
    CALL ASSOCIATE_MEMBER(SELF%MEMBERS)
  CLASS IS(${ft.name}$_STACK_WRAPPER)
    CALL ASSOCIATE_MEMBER(SELF%MEMBERS)
  END SELECT

  CONTAINS
    SUBROUTINE ASSOCIATE_MEMBER(MEMBERS)
      TYPE(FIELD_BASIC_PTR), INTENT(IN):: MEMBERS(:)
      ASSOCIATE(FLD => MEMBERS(IDX)%PTR)
        SELECT TYPE(FLD)
        CLASS IS(FIELD_${RANK-1}$${SUFF}$)
          MEMBER => FLD
        END SELECT
      END ASSOCIATE
    END SUBROUTINE
END SUBROUTINE ${ft.name}$_GET_STACK_MEMBER_0

MODULE SUBROUTINE ${ft.name}$_GET_STACK_MEMBER_1(SELF, IDX, MEMBER)
  CLASS(${ft.name}$), INTENT(IN) :: SELF
  INTEGER(KIND=JPIM), INTENT(IN) :: IDX
  CLASS(FIELD_${RANK}$${SUFF}$), POINTER, INTENT(INOUT) :: MEMBER

  SELECT TYPE(SELF)
  CLASS IS(${ft.name}$_STACK_OWNER)
    CALL ASSOCIATE_MEMBER(SELF%MEMBERS)
  CLASS IS(${ft.name}$_STACK_WRAPPER)
    CALL ASSOCIATE_MEMBER(SELF%MEMBERS)
  END SELECT

  CONTAINS
    SUBROUTINE ASSOCIATE_MEMBER(MEMBERS)
      TYPE(FIELD_BASIC_PTR), INTENT(IN):: MEMBERS(:)
      ASSOCIATE(FLD => MEMBERS(IDX)%PTR)
        SELECT TYPE(FLD)
        CLASS IS(FIELD_${RANK}$${SUFF}$)
          MEMBER => FLD
        END SELECT
      END ASSOCIATE
    END SUBROUTINE
END SUBROUTINE ${ft.name}$_GET_STACK_MEMBER_1

#:endif
#:endfor

END SUBMODULE FIELD_${RANK}$${SUFF}$_FACTORY_STACK_MODULE
