#! (C) Copyright 2022- ECMWF.
#! (C) Copyright 2022- Meteo-France.
#! (C) Copyright 2023- NVIDIA
#!
#! This software is licensed under the terms of the Apache Licence Version 2.0
#! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
#! In applying this licence, ECMWF does not waive the privileges and immunities
#! granted to it by virtue of its status as an intergovernmental organisation
#! nor does it submit to any jurisdiction.

MODULE FIELD_${RANK}$${SUFF}$_DATA_MODULE

#:set fieldTypeList = fieldType.getFieldTypeList (ranks=[RANK], kinds=['JP' + str (SUFF)])

USE FIELD_CONSTANTS_MODULE
${fieldType.useParkind1 ()}$

IMPLICIT NONE

PRIVATE

#:for ft in fieldTypeList
#:set ftn = ft.name

PUBLIC :: ${ftn}$_COPY

#:endfor

CONTAINS

#:for ft in fieldTypeList
#:set ftn = ft.name

  SUBROUTINE ${ftn}$_COPY (HST, DEV, MAP_DEVPTR, KDIR, QUEUE)

    USE FIELD_ABORT_MODULE

    ${ft.type}$, POINTER :: HST (${ft.shape}$), DEV (${ft.shape}$)
    LOGICAL,                       INTENT (IN) :: MAP_DEVPTR
    INTEGER (KIND=JPIM),           INTENT (IN) :: KDIR
    INTEGER (KIND=JPIM), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER :: LAST_CONTIG_DIM
    INTEGER :: NEXT_CONTIG_DIM

    LAST_CONTIG_DIM = ${ftn}$_GET_LAST_CONTIGUOUS_DIMENSION (HST, 0)
    NEXT_CONTIG_DIM = ${ftn}$_GET_LAST_CONTIGUOUS_DIMENSION (HST, LAST_CONTIG_DIM+1)

    SELECT CASE (LAST_CONTIG_DIM)
#:if defined('CUDA')
      CASE (${ft.rank}$)
        CALL ${ftn}$_COPY_DIM${ft.rank}$_CONTIGUOUS (HST, DEV, MAP_DEVPTR, KDIR, QUEUE)
#:for d1 in range (ft.rank)
      CASE (${d1}$)
        SELECT CASE (NEXT_CONTIG_DIM)
          #:for d2 in range (d1+1, ft.rank+1)
          CASE (${d2}$)
            CALL ${ftn}$_COPY_2D_DIM${d1}$_${d2}$_CONTIGUOUS (HST, DEV, MAP_DEVPTR, KDIR, QUEUE)
          #:endfor
          CASE DEFAULT
            CALL FIELD_ABORT ('INTERNAL ERROR: UNEXPECTED NEXT_CONTIG_DIM')
        END SELECT
#:endfor
#:else
#:for d in range (ft.rank + 1)
      CASE (${d}$)
        CALL ${ftn}$_COPY_DIM${d}$_CONTIGUOUS (HST, DEV, MAP_DEVPTR, KDIR, QUEUE)
#:endfor
#:endif
      CASE DEFAULT
        CALL FIELD_ABORT ('INTERNAL ERROR: UNEXPECTED LAST_CONTIG_DIM')
    END SELECT

  END SUBROUTINE

#:for d in range (0, ft.rank+1)
  SUBROUTINE ${ftn}$_COPY_DIM${d}$_CONTIGUOUS (HST, DEV, MAP_DEVPTR, KDIR, QUEUE)
#ifdef _OPENACC
  USE OPENACC
#endif
    ${ft.type}$, POINTER :: HST (${ft.shape}$), DEV (${ft.shape}$)
    LOGICAL,                       INTENT (IN) :: MAP_DEVPTR
    INTEGER (KIND=JPIM),           INTENT (IN) :: KDIR
    INTEGER (KIND=JPIM), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER (KIND=JPIM) :: ISIZE
    INTEGER :: ${', '.join (['J'] + list (map (lambda i: 'J' + str (i+1), range (d, ft.rank))))}$
#ifdef _OPENACC
    TYPE(C_DEVPTR) :: DEVPTR
#endif

  #:for e in range (ft.rank, d, -1)
    ${'  ' * (ft.rank - e)}$DO J${e}$ = LBOUND (HST, ${e}$), UBOUND (HST, ${e}$)
  #:endfor
  #:set ar = ', '.join ([':'] * d  + list (map (lambda i: 'J' + str (i+1), range (d, ft.rank))))
  #:set indent = '  ' * (ft.rank - e)
#ifdef _OPENACC
    ${indent}$  IF(MAP_DEVPTR)THEN
    ${indent}$    DEVPTR = ACC_DEVICEPTR(DEV (${ar}$))
    ${indent}$  ELSE
  #:if defined('CUDA')
  !$acc data deviceptr(DEVPTR, DEV)
    ${indent}$    DEVPTR = C_DEVLOC(DEV (${ar}$))
  !$acc end data
  #:endif
    ${indent}$  ENDIF
#endif
    #:if d == 0
    ${indent}$  ISIZE = KIND (HST)
    #:else
    ${indent}$  ISIZE = KIND (HST) * SIZE (HST (${ar}$))
    #:endif
    ${indent}$  IF (KDIR == NH2D) THEN
#ifdef _OPENACC
    ${indent}$    IF(PRESENT(QUEUE))THEN
    ${indent}$      CALL ACC_MEMCPY_TO_DEVICE_ASYNC (DEVPTR , HST (${ar}$), ISIZE, QUEUE)
    ${indent}$    ELSE
    ${indent}$      CALL ACC_MEMCPY_TO_DEVICE (DEVPTR , HST (${ar}$), ISIZE)
    ${indent}$    ENDIF
#else
    ${indent}$    DEV (${ar}$) = HST (${ar}$)
#endif
    ${indent}$  ELSEIF (KDIR == ND2H) THEN
#ifdef _OPENACC
    ${indent}$    IF(PRESENT(QUEUE))THEN
    ${indent}$      CALL ACC_MEMCPY_FROM_DEVICE_ASYNC (HST (${ar}$), DEVPTR, ISIZE, QUEUE)
    ${indent}$    ELSE
    ${indent}$      CALL ACC_MEMCPY_FROM_DEVICE (HST (${ar}$), DEVPTR, ISIZE)
    ${indent}$    ENDIF
#else
    ${indent}$    HST (${ar}$) = DEV (${ar}$)
#endif
    ${indent}$  ENDIF
  #:for e in range (d, ft.rank)
    ${'  ' * (ft.rank - e - 1)}$ENDDO
  #:endfor
    END SUBROUTINE

#:endfor

#:if defined('CUDA')
#:for d1 in range (0, ft.rank)
#:for d2 in range (d1+1, ft.rank+1)
    SUBROUTINE ${ftn}$_COPY_2D_DIM${d1}$_${d2}$_CONTIGUOUS (HST, DEV, MAP_DEVPTR, KDIR, QUEUE)
    USE OPENACC
    USE CUDAFOR
    USE FIELD_ABORT_MODULE

    ${ft.type}$, POINTER :: HST (${ft.shape}$), DEV (${ft.shape}$)
    INTEGER (KIND=JPIM),           INTENT (IN) :: KDIR
    LOGICAL,                       INTENT (IN) :: MAP_DEVPTR
    INTEGER (KIND=JPIM), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER (KIND=JPIM) :: IHST_PITCH, IDEV_PITCH, IRET
    INTEGER (KIND=JPIM) :: IWIDTH, IHEIGHT, ISHP(${ft.rank+1}$)
  #:if d2 < ft.rank
    INTEGER :: ${', '.join (list (map (lambda i: 'J' + str (i+1), range (d2, ft.rank))))}$
  #:endif
    INTEGER(KIND=CUDA_STREAM_KIND) :: STREAM
    TYPE(C_PTR) :: HSTPTR
    TYPE(C_DEVPTR) :: DEVPTR

    ISHP(1) = 1
    ISHP(2:) = SHAPE(HST)
    IWIDTH = PRODUCT(ISHP(1:${d1+1}$)) * KIND(HST)
    IHEIGHT = PRODUCT(ISHP(${d1+2}$:${d2+1}$))

#:set lb = lambda arr, i: f'LBOUND({arr}, {i+1})'
#:set lbnds = lambda arr, start, end: [lb(arr, i) for i in range(start, end)]
#:set this_slice = lambda arr: ', '.join(lbnds(arr, 0, ft.rank))
#:set next_slice = lambda arr: ', '.join(lbnds(arr, 0, d1) + [lb(arr, d1)+'+1'] + lbnds(arr, d1+1, ft.rank))
    IHST_PITCH = LOC (HST(${next_slice('HST')}$)) - LOC (HST (${this_slice('HST')}$))
    IDEV_PITCH = LOC (DEV(${next_slice('DEV')}$)) - LOC (DEV (${this_slice('DEV')}$))

  #:for e in range (ft.rank, d2, -1)
    ${'  ' * (ft.rank - e)}$DO J${e}$ = LBOUND (HST, ${e}$), UBOUND (HST, ${e}$)
  #:endfor
  #:set indent = '  ' * (ft.rank - d2 - 1)
  #:set ar = lambda arr: ', '.join(lbnds(arr, 0, d2) + [f'J{i+1}' for i in range(d2, ft.rank)])
    ${indent}$  HSTPTR = C_LOC(HST (${ar('HST')}$))
    ${indent}$  IF (MAP_DEVPTR) THEN
    ${indent}$     !$acc host_data use_device(DEV)
    ${indent}$     DEVPTR = C_DEVLOC(DEV (${ar('DEV')}$))
    ${indent}$     !$acc end host_data
    ${indent}$  ELSE
    ${indent}$     !$acc data deviceptr(DEVPTR,DEV)
    ${indent}$     DEVPTR = C_DEVLOC(DEV (${ar('DEV')}$))
    ${indent}$     !$acc end data
    ${indent}$  ENDIF
    ${indent}$  IF (KDIR == NH2D) THEN
    ${indent}$    IF(PRESENT(QUEUE)) THEN
    ${indent}$      CALL ACC_SET_CUDA_STREAM(QUEUE, STREAM)
    ${indent}$      IRET = CUDAMEMCPY2DASYNC (DEVPTR, IDEV_PITCH, &
    ${indent}$                              & HSTPTR, IHST_PITCH, &
    ${indent}$                              & IWIDTH, IHEIGHT, &
    ${indent}$                              & STREAM=STREAM)
    ${indent}$    ELSE
    ${indent}$      IRET = CUDAMEMCPY2D (DEVPTR, IDEV_PITCH, &
    ${indent}$                         & HSTPTR, IHST_PITCH, &
    ${indent}$                         & IWIDTH, IHEIGHT)
    ${indent}$    ENDIF
    ${indent}$    IF (IRET /= CUDASUCCESS) THEN
    ${indent}$       CALL FIELD_ABORT ("${ftn}$_COPY_2D_DIM${d1}$_${d2}$_CONTIGUOUS: HOST-TO-DEVICE TRANSFER FAILED")
    ${indent}$    ENDIF
    ${indent}$  ELSEIF (KDIR == ND2H) THEN
    ${indent}$    IF(PRESENT(QUEUE)) THEN
    ${indent}$      CALL ACC_SET_CUDA_STREAM(QUEUE, STREAM)
    ${indent}$      IRET = CUDAMEMCPY2DASYNC (HSTPTR, IHST_PITCH, &
    ${indent}$                              & DEVPTR, IDEV_PITCH, &
    ${indent}$                              & IWIDTH, IHEIGHT, &
    ${indent}$                              & STREAM=STREAM)
    ${indent}$    ELSE
    ${indent}$      IRET = CUDAMEMCPY2D (HSTPTR, IHST_PITCH, &
    ${indent}$                         & DEVPTR, IDEV_PITCH, &
    ${indent}$                         & IWIDTH, IHEIGHT)
    ${indent}$    ENDIF
    ${indent}$    IF (IRET /= CUDASUCCESS) THEN
    ${indent}$       CALL FIELD_ABORT ("${ftn}$_COPY_2D_DIM${d1}$_${d2}$_CONTIGUOUS: DEVICE-TO-HOST TRANSFER FAILED")
    ${indent}$    ENDIF
    ${indent}$  ENDIF
  #:for e in range (d2, ft.rank)
    ${'  ' * (ft.rank - e - 1)}$ENDDO
  #:endfor
    END SUBROUTINE
#:endfor
#:endfor
#:endif

#:endfor

#:for ft in fieldTypeList
#:set ftn = ft.name

  INTEGER (KIND=JPIM) FUNCTION ${ftn}$_GET_LAST_CONTIGUOUS_DIMENSION (PTR, AFTER) RESULT (JDIM)
  ${ft.type}$, POINTER :: PTR (${ft.shape}$)
  INTEGER (KIND=JPIM) :: AFTER
  INTEGER*8 :: IPREVIOUS_STRIDE, ITHIS_STRIDE, ISIZE
  INTEGER (KIND=JPIM) :: J, LB(${ft.rank}$)

  ! assume that dimension all dimensions before AFTER are contiguous...

  LB = LBOUND(PTR)
  IF (AFTER == 0) THEN
    IPREVIOUS_STRIDE = KIND (PTR)
  ENDIF

#:for d in range (1, ft.rank+1)
  #:set ind0 = ""
  #:set ind1 = ""
  #:for i in range(1,ft.rank+1)
    #:set ind0 = ind0 + "LB({}), ".format(i)
    #:set ind1 = ind1 + "LB({}){}, ".format(i,"+1"*(i==d))
  #:endfor
  #:set ind0 = ind0[:-2]
  #:set ind1 = ind1[:-2]
  ITHIS_STRIDE = LOC (PTR (${ind1}$)) - LOC (PTR (${ind0}$))
  IF (AFTER < ${d}$) THEN
   #:if d == 1
    ISIZE = 1
   #:else
    ISIZE = SIZE(PTR, ${d-1}$)
   #:endif
    IF (SIZE(PTR, ${d}$) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = ${d-1}$
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == ${d}$) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

#:endfor
  JDIM = ${ft.rank}$
  END FUNCTION ${ftn}$_GET_LAST_CONTIGUOUS_DIMENSION

#:endfor

END MODULE FIELD_${RANK}$${SUFF}$_DATA_MODULE
