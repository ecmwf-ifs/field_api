#! (C) Copyright 2022- ECMWF.
#! (C) Copyright 2022- Meteo-France.
#!
#! This software is licensed under the terms of the Apache Licence Version 2.0
#! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
#! In applying this licence, ECMWF does not waive the privileges and immunities
#! granted to it by virtue of its status as an intergovernmental organisation
#! nor does it submit to any jurisdiction.

MODULE FIELD_${RANK}$${SUFF}$_FACTORY_MODULE

#:set fieldTypeList = fieldType.getFieldTypeList (ranks=[RANK], kinds=['JP' + str (SUFF)])

USE FIELD_MODULE
${fieldType.useParkind1 ()}$

IMPLICIT NONE

#include "abor1.intfb.h"

CONTAINS

#:for ft in fieldTypeList
SUBROUTINE ${ft.name}$_NEW_OWNER (FIELD_PTR, UBOUNDS, LBOUNDS, PERSISTENT, DELAYED, INIT_VALUE)

CLASS(${ft.name}$), POINTER :: FIELD_PTR
TYPE(${ft.name}$_OWNER), POINTER :: FIELD_OWNER
INTEGER(KIND=JPIM), INTENT(IN) :: UBOUNDS (${ft.rank}$)
INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS (${ft.rank}$)
LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
LOGICAL, OPTIONAL,  INTENT(IN) :: DELAYED
${ft.type}$, OPTIONAL, INTENT(IN) :: INIT_VALUE

ALLOCATE (FIELD_OWNER)

CALL FIELD_OWNER%INIT (LBOUNDS=LBOUNDS, UBOUNDS=UBOUNDS, PERSISTENT=PERSISTENT, DELAYED=DELAYED, INIT_VALUE=INIT_VALUE)

FIELD_PTR => FIELD_OWNER

END SUBROUTINE

SUBROUTINE ${ft.name}$_NEW_WRAPPER (FIELD_PTR, LBOUNDS, PERSISTENT, DATA)

CLASS(${ft.name}$), POINTER :: FIELD_PTR
${ft.type}$, TARGET, INTENT (IN) :: DATA (${ft.shape}$)
TYPE(${ft.name}$_WRAPPER), POINTER :: FIELD_WRAPPER
INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS (${ft.rank}$)
LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT

ALLOCATE (FIELD_WRAPPER)

CALL FIELD_WRAPPER%INIT (DATA, LBOUNDS=LBOUNDS, PERSISTENT=PERSISTENT)

FIELD_PTR => FIELD_WRAPPER

END SUBROUTINE

#:if ft.rank > 2
SUBROUTINE ${ft.name}$_DELETE (FIELD_PTR, CHILDREN)
CLASS(${ft.name}$), POINTER :: FIELD_PTR
TYPE(${f'FIELD_{ft.rank-1}{ft.suffix}'}$_PTR), ALLOCATABLE, OPTIONAL :: CHILDREN(:)
#:else
SUBROUTINE ${ft.name}$_DELETE (FIELD_PTR)
CLASS(${ft.name}$), POINTER :: FIELD_PTR
#:endif

CALL FIELD_PTR%FINAL ()
DEALLOCATE (FIELD_PTR)
NULLIFY (FIELD_PTR)

#:if ft.rank > 2
IF(PRESENT(CHILDREN))THEN
  DEALLOCATE(CHILDREN)
ELSE
  SELECT TYPE(FIELD_PTR)
    TYPE IS (${ft.name}$_BUFFER_OWNER)
       CALL ABOR1("${ft.name}$_DELETE: CHILDREN FIELDS MUST ALSO BE DELETED")
    TYPE IS (${ft.name}$_BUFFER_WRAPPER)
       CALL ABOR1("${ft.name}$_DELETE: CHILDREN FIELDS MUST ALSO BE DELETED")
  END SELECT
ENDIF
#:endif

END SUBROUTINE

#:if ft.rank > 2
SUBROUTINE ${ft.name}$_NEW_BUFFER_WRAPPER (FIELD_PTR, NUM_CHILDREN, CHILDREN, LBOUNDS, DATA, PERSISTENT, CONTIG_FIELDS)

CLASS(${ft.name}$), POINTER, INTENT(OUT) :: FIELD_PTR
INTEGER(KIND=JPIM), INTENT(IN) :: NUM_CHILDREN
TYPE(${f'FIELD_{ft.rank-1}{ft.suffix}'}$_PTR), ALLOCATABLE, INTENT(OUT) :: CHILDREN(:)

${ft.type}$, OPTIONAL, TARGET, INTENT (IN) :: DATA (${ft.shape}$)
INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS (${ft.rank}$)
LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
LOGICAL, OPTIONAL, INTENT(IN) :: CONTIG_FIELDS

TYPE(${ft.name}$_BUFFER_WRAPPER), POINTER :: FIELD_BUFFER

ALLOCATE(FIELD_BUFFER)
ALLOCATE(CHILDREN(NUM_CHILDREN))
CALL FIELD_BUFFER%BUFFER_INIT(NUM_CHILDREN, CHILDREN, LBOUNDS=LBOUNDS, DATA=DATA, PERSISTENT=PERSISTENT, &
&                             CONTIG_FIELDS=CONTIG_FIELDS)

FIELD_PTR => FIELD_BUFFER

END SUBROUTINE ${ft.name}$_NEW_BUFFER_WRAPPER

SUBROUTINE ${ft.name}$_NEW_BUFFER_OWNER (FIELD_PTR, NUM_CHILDREN, CHILDREN, LBOUNDS, UBOUNDS, PERSISTENT, CONTIG_FIELDS, INIT_VALUE)

CLASS(${ft.name}$), POINTER, INTENT(OUT) :: FIELD_PTR
INTEGER(KIND=JPIM), INTENT(IN) :: NUM_CHILDREN
TYPE(${f'FIELD_{ft.rank-1}{ft.suffix}'}$_PTR), ALLOCATABLE, INTENT(OUT) :: CHILDREN(:)

INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS (${ft.rank}$)
INTEGER(KIND=JPIM), INTENT(IN) :: UBOUNDS (${ft.rank}$)
LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
LOGICAL, OPTIONAL, INTENT(IN) :: CONTIG_FIELDS
${ft.type}$, OPTIONAL, INTENT(IN) :: INIT_VALUE

TYPE(${ft.name}$_BUFFER_OWNER), POINTER :: FIELD_BUFFER

ALLOCATE(FIELD_BUFFER)
ALLOCATE(CHILDREN(NUM_CHILDREN))
CALL FIELD_BUFFER%BUFFER_INIT(NUM_CHILDREN, CHILDREN, LBOUNDS=LBOUNDS, UBOUNDS=UBOUNDS, PERSISTENT=PERSISTENT, &
&                             CONTIG_FIELDS=CONTIG_FIELDS, INIT_VALUE=INIT_VALUE)

FIELD_PTR => FIELD_BUFFER

END SUBROUTINE ${ft.name}$_NEW_BUFFER_OWNER
#:endif

#:endfor

END MODULE FIELD_${RANK}$${SUFF}$_FACTORY_MODULE
