#! (C) Copyright 2022- ECMWF.
#! (C) Copyright 2022- Meteo-France.
#!
#! This software is licensed under the terms of the Apache Licence Version 2.0
#! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
#! In applying this licence, ECMWF does not waive the privileges and immunities
#! granted to it by virtue of its status as an intergovernmental organisation
#! nor does it submit to any jurisdiction.

MODULE FIELD_${RANK}$${SUFF}$_BUFFER_MODULE

#:set fieldTypeList = fieldType.getFieldTypeList (ranks=[RANK], kinds=['JP' + str (SUFF)])

#:for ft in fieldTypeList
USE ${ft.name}$_MODULE, ONLY : ${ft.name}$, ${ft.name}$_OWNER, ${ft.name}$_WRAPPER, NDEVFRESH, NHSTFRESH
USE ${f'FIELD_{ft.rank-1}{ft.suffix}'}$_MODULE, ONLY : ${f'FIELD_{ft.rank-1}{ft.suffix}'}$, &
& ${f'FIELD_{ft.rank-1}{ft.suffix}'}$_WRAPPER, ${f'FIELD_{ft.rank-1}{ft.suffix}'}$_PTR
#:endfor
USE OML_MOD, ONLY: OML_MY_THREAD 
USE FIELD_INIT_DEBUG_VALUE_MODULE
${fieldType.useParkind1 ()}$

IMPLICIT NONE

#include "abor1.intfb.h"

PRIVATE

#:for ft in fieldTypeList
#:set ftn = ft.name
TYPE, EXTENDS(${ftn}$_WRAPPER) :: ${ftn}$_BUFFER_WRAPPER
   INTEGER(KIND=JPIM) :: NUM_CHILDREN = 0
   LOGICAL :: CONTIG_FIELDS = .FALSE.
   TYPE(${f'FIELD_{ft.rank-1}{ft.suffix}'}$_PTR), PRIVATE, POINTER :: CHILDREN(:) => NULL()

CONTAINS
   PROCEDURE :: BUFFER_INIT => ${ftn}$_BUFFER_WRAPPER_INIT
   PROCEDURE :: FINAL => ${ftn}$_BUFFER_WRAPPER_FINAL
   PROCEDURE :: GET_VIEW => ${ftn}$_BUFFER_WRAPPER_GET_VIEW
   PROCEDURE :: GET_DEVICE_DATA_RDONLY => ${ftn}$_BUFFER_WRAPPER_GET_DEVICE_DATA_RDONLY
   PROCEDURE :: GET_DEVICE_DATA_RDWR => ${ftn}$_BUFFER_WRAPPER_GET_DEVICE_DATA_RDWR
#!   PROCEDURE :: GET_HOST_DATA => ${ftn}$_BUFFER_WRAPPER_GET_HOST_DATA
END TYPE ${ftn}$_BUFFER_WRAPPER

PUBLIC :: ${ftn}$_BUFFER_WRAPPER

TYPE, EXTENDS(${ftn}$_OWNER) :: ${ftn}$_BUFFER_OWNER
   INTEGER(KIND=JPIM) :: NUM_CHILDREN = 0
   LOGICAL :: CONTIG_FIELDS = .FALSE.
   TYPE(${f'FIELD_{ft.rank-1}{ft.suffix}'}$_PTR), PRIVATE, POINTER :: CHILDREN(:) => NULL()

CONTAINS
   PROCEDURE :: BUFFER_INIT => ${ftn}$_BUFFER_OWNER_INIT
   PROCEDURE :: FINAL => ${ftn}$_BUFFER_OWNER_FINAL
   PROCEDURE :: GET_VIEW => ${ftn}$_BUFFER_OWNER_GET_VIEW
   PROCEDURE :: GET_DEVICE_DATA_RDONLY => ${ftn}$_BUFFER_OWNER_GET_DEVICE_DATA_RDONLY
   PROCEDURE :: GET_DEVICE_DATA_RDWR => ${ftn}$_BUFFER_OWNER_GET_DEVICE_DATA_RDWR
#!   PROCEDURE :: GET_HOST_DATA => ${ftn}$_BUFFER_OWNER_GET_HOST_DATA
END TYPE ${ftn}$_BUFFER_OWNER

PUBLIC :: ${ftn}$_BUFFER_OWNER

#:endfor

CONTAINS

#:for ft in fieldTypeList
#:set ftn = ft.name + '_BUFFER'
SUBROUTINE ${ftn}$_WRAPPER_INIT(SELF, NUM_CHILDREN, CHILDREN, LBOUNDS, DATA, PERSISTENT, CONTIG_FIELDS)
  CLASS(${ftn}$_WRAPPER) :: SELF
  
  INTEGER(KIND=JPIM), INTENT(IN) :: NUM_CHILDREN
  TYPE(${f'FIELD_{ft.rank-1}{ft.suffix}'}$_PTR), INTENT(INOUT) :: CHILDREN(:)
  
  INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS (${ft.rank}$)
  ${ft.type}$, OPTIONAL, TARGET, INTENT (IN) :: DATA (${ft.shape}$)
  LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
  LOGICAL, OPTIONAL, INTENT(IN) :: CONTIG_FIELDS
  
  LOGICAL :: LLPERSISTENT
  INTEGER(KIND=JPIM) :: LLBOUNDS(${ft.rank}$), IFIELD
  ${ft.type}$ :: LINIT_VALUE

  SELF%NUM_CHILDREN = NUM_CHILDREN
  IF(PRESENT(CONTIG_FIELDS)) SELF%CONTIG_FIELDS = CONTIG_FIELDS
  
  !...Set lower bounds
  LLBOUNDS(:) =  1
  IF(PRESENT(LBOUNDS)) LLBOUNDS = LBOUNDS
  IF(SELF%CONTIG_FIELDS)THEN
    LLBOUNDS(${ft.rank}$) = 1
  ELSE
    LLBOUNDS(${ft.rank-1}$) = 1
  ENDIF

  !...Consistency checks
  IF(SELF%CONTIG_FIELDS)THEN
     IF(UBOUND(DATA, ${ft.rank}$) /= NUM_CHILDREN)THEN
        CALL ABOR1('${ftn}$_WRAPPER_INIT: DIMENSION MISMATCH')
     ENDIF
  ELSE
     IF(UBOUND(DATA, ${ft.rank-1}$) /= NUM_CHILDREN)THEN
        CALL ABOR1('${ftn}$_WRAPPER_INIT: DIMENSION MISMATCH')
     ENDIF
  ENDIF
  
  !...Wrapper fields are persistent by default
  LLPERSISTENT = .TRUE.
  IF(PRESENT(PERSISTENT)) LLPERSISTENT = PERSISTENT
  
  IF(.NOT. LLPERSISTENT .AND. SELF%CONTIG_FIELDS)THEN
      CALL ABOR1('${ftn}$_WRAPPER_INIT: Thread-local temporaries must be block-strided')
  ENDIF

  CALL SELF%${ft.name}$_WRAP(DATA=DATA, LBOUNDS=LLBOUNDS, PERSISTENT=LLPERSISTENT)

  CALL ${ftn}$_ASSIGN_CHILDREN(NUM_CHILDREN, SELF%CHILDREN, CHILDREN, SELF%PTR, LLPERSISTENT, SELF%CONTIG_FIELDS)
END SUBROUTINE ${ftn}$_WRAPPER_INIT

SUBROUTINE ${ftn}$_OWNER_INIT(SELF, NUM_CHILDREN, CHILDREN, LBOUNDS, UBOUNDS, &
&                             PERSISTENT, INIT_VALUE, CONTIG_FIELDS)
  CLASS(${ftn}$_OWNER) :: SELF
  
  INTEGER(KIND=JPIM), INTENT(IN) :: NUM_CHILDREN
  TYPE(${f'FIELD_{ft.rank-1}{ft.suffix}'}$_PTR), INTENT(INOUT) :: CHILDREN(:)
  
  INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS (${ft.rank}$)
  INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: UBOUNDS (${ft.rank}$)
  LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
  LOGICAL, OPTIONAL, INTENT(IN) :: CONTIG_FIELDS
  ${ft.type}$, OPTIONAL, INTENT(IN) :: INIT_VALUE
  
  LOGICAL :: LLPERSISTENT
  INTEGER(KIND=JPIM) :: LLBOUNDS(${ft.rank}$), IFIELD
  ${ft.type}$ :: LINIT_VALUE

  SELF%NUM_CHILDREN = NUM_CHILDREN
  IF(PRESENT(CONTIG_FIELDS)) SELF%CONTIG_FIELDS = CONTIG_FIELDS
  
  !...Set lower bounds
  LLBOUNDS(:) =  1
  IF(PRESENT(LBOUNDS)) LLBOUNDS = LBOUNDS
  IF(SELF%CONTIG_FIELDS)THEN
    LLBOUNDS(${ft.rank}$) = 1
  ELSE
    LLBOUNDS(${ft.rank-1}$) = 1
  ENDIF

  !...Consistency checks
  IF(SELF%CONTIG_FIELDS)THEN
     IF(UBOUNDS(${ft.rank}$) /= NUM_CHILDREN)THEN
        CALL ABOR1('${ftn}$_OWNER_INIT: DIMENSION MISMATCH')
     ENDIF
  ELSE
     IF(UBOUNDS(${ft.rank-1}$) /= NUM_CHILDREN)THEN
        CALL ABOR1('${ftn}$_OWNER_INIT: DIMENSION MISMATCH')
     ENDIF
  ENDIF
  
  !...Owner fields are thread-local by default
  LLPERSISTENT = .FALSE.
  IF(PRESENT(PERSISTENT)) LLPERSISTENT = PERSISTENT
  
  IF(.NOT. LLPERSISTENT .AND. SELF%CONTIG_FIELDS)THEN
      CALL ABOR1('${ftn}$_OWNER_INIT: Thread-local temporaries must be block-strided')
  ENDIF

  !...FieldBuffer must be initialised
  LINIT_VALUE = INIT_DEBUG_VALUE_${ft.kind}$
  IF(PRESENT(INIT_VALUE))THEN
     LINIT_VALUE = INIT_VALUE
  ENDIF

  CALL SELF%${ft.name}$_OWNER_INIT(LBOUNDS=LBOUNDS, UBOUNDS=UBOUNDS, PERSISTENT=LLPERSISTENT, INIT_VALUE=LINIT_VALUE)

  CALL ${ftn}$_ASSIGN_CHILDREN(NUM_CHILDREN, SELF%CHILDREN, CHILDREN, SELF%PTR, LLPERSISTENT, SELF%CONTIG_FIELDS)
END SUBROUTINE ${ftn}$_OWNER_INIT

SUBROUTINE ${ftn}$_WRAPPER_FINAL(SELF)
  CLASS(${ftn}$_WRAPPER) :: SELF
  INTEGER(KIND=JPIM) :: IFIELD

  DO IFIELD=1,SELF%NUM_CHILDREN
     CALL SELF%CHILDREN(IFIELD)%PTR%FINAL()
     IF(ASSOCIATED(SELF%CHILDREN(IFIELD)%PTR))THEN
       DEALLOCATE(SELF%CHILDREN(IFIELD)%PTR)
       NULLIFY(SELF%CHILDREN(IFIELD)%PTR)
     ENDIF
  ENDDO

  CALL SELF%${ft.name}$_WRAPPER_FINAL
END SUBROUTINE ${ftn}$_WRAPPER_FINAL

SUBROUTINE ${ftn}$_OWNER_FINAL(SELF)
  CLASS(${ftn}$_OWNER) :: SELF
  INTEGER(KIND=JPIM) :: IFIELD

  DO IFIELD=1,SELF%NUM_CHILDREN
     CALL SELF%CHILDREN(IFIELD)%PTR%FINAL()
     IF(ASSOCIATED(SELF%CHILDREN(IFIELD)%PTR))THEN
       DEALLOCATE(SELF%CHILDREN(IFIELD)%PTR)
       NULLIFY(SELF%CHILDREN(IFIELD)%PTR)
     ENDIF
  ENDDO

  CALL SELF%${ft.name}$_OWNER_FINAL
END SUBROUTINE ${ftn}$_OWNER_FINAL

SUBROUTINE ${ftn}$_ASSIGN_CHILDREN(NUM_CHILDREN, CHILDREN_, CHILDREN, DATA, PERSISTENT, CONTIG_FIELDS)
  INTEGER(KIND=JPIM), INTENT(IN) :: NUM_CHILDREN
  TYPE(${f'FIELD_{ft.rank-1}{ft.suffix}'}$_PTR), POINTER, INTENT(OUT) :: CHILDREN_(:)
  TYPE(${f'FIELD_{ft.rank-1}{ft.suffix}'}$_PTR), TARGET, INTENT(INOUT) :: CHILDREN(:)
  LOGICAL, INTENT(IN) :: PERSISTENT, CONTIG_FIELDS
  ${ft.type}$, INTENT(IN) :: DATA(${ft.shape}$)

  INTEGER(KIND=JPIM), DIMENSION(${ft.rank-1}$) :: LBOUNDS
  INTEGER(KIND=JPIM) :: IFIELD

  DO IFIELD=1,NUM_CHILDREN
     ALLOCATE(${f'FIELD_{ft.rank-1}{ft.suffix}'}$_WRAPPER::CHILDREN(IFIELD)%PTR)
  ENDDO

  IF(CONTIG_FIELDS)THEN
     #:for r in range(1, ft.rank)
     LBOUNDS(${r}$) = LBOUND(DATA, ${r}$)
     #:endfor

     #:set ar = (',').join([':' for _ in range(0, ft.rank-1)])
     DO IFIELD=1,NUM_CHILDREN
        CALL ${f'FIELD_{ft.rank-1}{ft.suffix}'}$_INIT_CHILD(CHILDREN(IFIELD)%PTR, DATA(${ar}$,IFIELD), LBOUNDS, PERSISTENT)
     ENDDO
  ELSE
     #:for r in range(1, ft.rank-1)
     LBOUNDS(${r}$) = LBOUND(DATA, ${r}$)
     #:endfor
     LBOUNDS(${ft.rank-1}$) = LBOUND(DATA, ${ft.rank}$)

     #:set ar = (',').join([':' for _ in range(0, ft.rank-2)])
     DO IFIELD=1,NUM_CHILDREN
        CALL ${f'FIELD_{ft.rank-1}{ft.suffix}'}$_INIT_CHILD(CHILDREN(IFIELD)%PTR, DATA(${ar}$,IFIELD,:), LBOUNDS, PERSISTENT)
     ENDDO
  ENDIF

  CHILDREN_ => CHILDREN

END SUBROUTINE ${ftn}$_ASSIGN_CHILDREN

SUBROUTINE ${f'FIELD_{ft.rank-1}{ft.suffix}'}$_INIT_CHILD(CHILD, DATA, LBOUNDS, PERSISTENT)
  CLASS(${f'FIELD_{ft.rank-1}{ft.suffix}'}$), INTENT(OUT) :: CHILD
  INTEGER(KIND=JPIM), INTENT(IN) :: LBOUNDS(${ft.rank-1}$)
  ${ft.type}$, INTENT(IN) :: DATA(${ft.viewShape}$)
  LOGICAL, INTENT(IN) :: PERSISTENT

  SELECT TYPE (CHILD)
  TYPE IS (${f'FIELD_{ft.rank-1}{ft.suffix}'}$_WRAPPER)
     CALL CHILD%INIT(DATA=DATA, LBOUNDS=LBOUNDS, PERSISTENT=PERSISTENT)
  END SELECT
END SUBROUTINE ${f'FIELD_{ft.rank-1}{ft.suffix}'}$_INIT_CHILD 

#!SUBROUTINE ${ftn}$_GET_HOST_DATA_RDWR(SELF, PPTR, QUEUE)
#!    CLASS(${ftn}$),   INTENT(INOUT) :: SELF
#!    ${ft.type}$, POINTER,         INTENT(INOUT) :: PPTR(${ft.shape}$)
#!    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
#!    INTEGER(KIND=JPIM) :: IFIELD
#!
#!    CALL SELF%BUFFER%GET_HOST_DATA_RDWR(PPTR, QUEUE=QUEUE)
#!
#!    DO IFIELD=1,SELF%NUM_FIELDS
#!       SELF%FIELDS(IFIELD)%PTR%ISTATUS = SELF%BUFFER%ISTATUS
#!    ENDDO
#!
#!END SUBROUTINE ${ftn}$_GET_HOST_DATA_RDWR
#!
#!SUBROUTINE ${ftn}$_GET_DEVICE_DATA_RDWR(SELF, PPTR, QUEUE)
#!    CLASS(${ftn}$),   INTENT(INOUT) :: SELF
#!    ${ft.type}$, POINTER,         INTENT(INOUT) :: PPTR(${ft.shape}$)
#!    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
#!    INTEGER(KIND=JPIM) :: IFIELD
#!
#!    CALL SELF%BUFFER%GET_DEVICE_DATA_RDWR(PPTR, QUEUE=QUEUE)
#!
#!    DO IFIELD=1,SELF%NUM_FIELDS
#!       SELF%FIELDS(IFIELD)%PTR%ISTATUS = SELF%BUFFER%ISTATUS
#!    ENDDO
#!
#!    IF(.NOT. ASSOCIATED(SELF%FIELDS(1)%PTR%DEVPTR))THEN
#!       IF(SELF%CONTIG_FIELDS)THEN
#!          #:set ar = (',').join([':' for _ in range(0, ft.rank-1)])
#!          DO IFIELD=1,SELF%NUM_FIELDS
#!             SELF%FIELDS(IFIELD)%PTR%DEVPTR => SELF%BUFFER%DEVPTR(${ar}$,IFIELD)
#!          ENDDO
#!       ELSE
#!          #:set ar = (',').join([':' for _ in range(0, ft.rank-2)])
#!          DO IFIELD=1,SELF%NUM_FIELDS
#!             SELF%FIELDS(IFIELD)%PTR%DEVPTR => SELF%BUFFER%DEVPTR(${ar}$,IFIELD,:)
#!          ENDDO
#!       ENDIF
#!    ENDIF
#!
#!END SUBROUTINE ${ftn}$_GET_DEVICE_DATA_RDWR
#!
#!SUBROUTINE ${ftn}$_GET_HOST_DATA_RDONLY(SELF, PPTR, QUEUE)
#!    CLASS(${ftn}$),   INTENT(INOUT) :: SELF
#!    ${ft.type}$, POINTER,         INTENT(INOUT) :: PPTR(${ft.shape}$)
#!    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
#!    INTEGER(KIND=JPIM) :: IFIELD
#!
#!    CALL SELF%BUFFER%GET_HOST_DATA_RDONLY(PPTR, QUEUE=QUEUE)
#!
#!    DO IFIELD=1,SELF%NUM_FIELDS
#!       SELF%FIELDS(IFIELD)%PTR%ISTATUS = SELF%BUFFER%ISTATUS
#!    ENDDO
#!
#!END SUBROUTINE ${ftn}$_GET_HOST_DATA_RDONLY
#!
#!SUBROUTINE ${ftn}$_GET_DEVICE_DATA_RDONLY(SELF, PPTR, QUEUE)
#!    CLASS(${ftn}$),   INTENT(INOUT) :: SELF
#!    ${ft.type}$, POINTER,         INTENT(INOUT) :: PPTR(${ft.shape}$)
#!    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
#!    INTEGER(KIND=JPIM) :: IFIELD
#!
#!    CALL SELF%BUFFER%GET_DEVICE_DATA_RDONLY(PPTR, QUEUE=QUEUE)
#!
#!    DO IFIELD=1,SELF%NUM_FIELDS
#!       SELF%FIELDS(IFIELD)%PTR%ISTATUS = SELF%BUFFER%ISTATUS
#!    ENDDO
#!
#!    IF(.NOT. ASSOCIATED(SELF%FIELDS(1)%PTR%DEVPTR))THEN
#!       IF(SELF%CONTIG_FIELDS)THEN
#!          #:set ar = (',').join([':' for _ in range(0, ft.rank-1)])
#!          DO IFIELD=1,SELF%NUM_FIELDS
#!             SELF%FIELDS(IFIELD)%PTR%DEVPTR => SELF%BUFFER%DEVPTR(${ar}$,IFIELD)
#!          ENDDO
#!       ELSE
#!          #:set ar = (',').join([':' for _ in range(0, ft.rank-2)])
#!          DO IFIELD=1,SELF%NUM_FIELDS
#!             SELF%FIELDS(IFIELD)%PTR%DEVPTR => SELF%BUFFER%DEVPTR(${ar}$,IFIELD,:)
#!          ENDDO
#!       ENDIF
#!    ENDIF
#!
#!END SUBROUTINE ${ftn}$_GET_DEVICE_DATA_RDONLY
#!
#!SUBROUTINE ${ftn}$_SYNC_HOST_RDWR(SELF, QUEUE)
#!    CLASS(${ftn}$),   INTENT(INOUT) :: SELF
#!    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
#!
#!    ${ft.type}$, POINTER :: PPTR(${ft.shape}$)
#!    INTEGER(KIND=JPIM) :: IFIELD
#!
#!    CALL SELF%BUFFER%GET_HOST_DATA_RDWR(PPTR, QUEUE=QUEUE)
#!
#!    DO IFIELD=1,SELF%NUM_FIELDS
#!       SELF%FIELDS(IFIELD)%PTR%ISTATUS = SELF%BUFFER%ISTATUS
#!    ENDDO
#!
#!END SUBROUTINE ${ftn}$_SYNC_HOST_RDWR
#!
#!SUBROUTINE ${ftn}$_SYNC_HOST_RDONLY(SELF, QUEUE)
#!    CLASS(${ftn}$),   INTENT(INOUT) :: SELF
#!    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
#!
#!    ${ft.type}$, POINTER :: PPTR(${ft.shape}$)
#!    INTEGER(KIND=JPIM) :: IFIELD
#!
#!    CALL SELF%BUFFER%GET_HOST_DATA_RDONLY(PPTR, QUEUE=QUEUE)
#!
#!    DO IFIELD=1,SELF%NUM_FIELDS
#!       SELF%FIELDS(IFIELD)%PTR%ISTATUS = SELF%BUFFER%ISTATUS
#!    ENDDO
#!
#!END SUBROUTINE ${ftn}$_SYNC_HOST_RDONLY
#!
#!SUBROUTINE ${ftn}$_SYNC_DEVICE_RDWR(SELF, QUEUE)
#!    CLASS(${ftn}$),   INTENT(INOUT) :: SELF
#!    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
#!    ${ft.type}$, POINTER :: PPTR(${ft.shape}$)
#!    INTEGER(KIND=JPIM) :: IFIELD
#!
#!    CALL SELF%BUFFER%GET_DEVICE_DATA_RDWR(PPTR, QUEUE=QUEUE)
#!
#!    DO IFIELD=1,SELF%NUM_FIELDS
#!       SELF%FIELDS(IFIELD)%PTR%ISTATUS = SELF%BUFFER%ISTATUS
#!    ENDDO
#!
#!    IF(.NOT. ASSOCIATED(SELF%FIELDS(1)%PTR%DEVPTR))THEN
#!       IF(SELF%CONTIG_FIELDS)THEN
#!          #:set ar = (',').join([':' for _ in range(0, ft.rank-1)])
#!          DO IFIELD=1,SELF%NUM_FIELDS
#!             SELF%FIELDS(IFIELD)%PTR%DEVPTR => SELF%BUFFER%DEVPTR(${ar}$,IFIELD)
#!          ENDDO
#!       ELSE
#!          #:set ar = (',').join([':' for _ in range(0, ft.rank-2)])
#!          DO IFIELD=1,SELF%NUM_FIELDS
#!             SELF%FIELDS(IFIELD)%PTR%DEVPTR => SELF%BUFFER%DEVPTR(${ar}$,IFIELD,:)
#!          ENDDO
#!       ENDIF
#!    ENDIF
#!
#!END SUBROUTINE ${ftn}$_SYNC_DEVICE_RDWR
#!
#!SUBROUTINE ${ftn}$_SYNC_DEVICE_RDONLY(SELF, QUEUE)
#!    CLASS(${ftn}$),   INTENT(INOUT) :: SELF
#!    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
#!    ${ft.type}$, POINTER :: PPTR(${ft.shape}$)
#!    INTEGER(KIND=JPIM) :: IFIELD
#!
#!    CALL SELF%BUFFER%GET_DEVICE_DATA_RDONLY(PPTR, QUEUE=QUEUE)
#!
#!    DO IFIELD=1,SELF%NUM_FIELDS
#!       SELF%FIELDS(IFIELD)%PTR%ISTATUS = SELF%BUFFER%ISTATUS
#!    ENDDO
#!
#!    IF(.NOT. ASSOCIATED(SELF%FIELDS(1)%PTR%DEVPTR))THEN
#!       IF(SELF%CONTIG_FIELDS)THEN
#!          #:set ar = (',').join([':' for _ in range(0, ft.rank-1)])
#!          DO IFIELD=1,SELF%NUM_FIELDS
#!             SELF%FIELDS(IFIELD)%PTR%DEVPTR => SELF%BUFFER%DEVPTR(${ar}$,IFIELD)
#!          ENDDO
#!       ELSE
#!          #:set ar = (',').join([':' for _ in range(0, ft.rank-2)])
#!          DO IFIELD=1,SELF%NUM_FIELDS
#!             SELF%FIELDS(IFIELD)%PTR%DEVPTR => SELF%BUFFER%DEVPTR(${ar}$,IFIELD,:)
#!          ENDDO
#!       ENDIF
#!    ENDIF
#!
#!END SUBROUTINE ${ftn}$_SYNC_DEVICE_RDONLY

SUBROUTINE ${ftn}$_GET_VIEW(VIEW_PTR, IDX, DATA, CONTIG_FIELDS)
  ${ft.type}$, POINTER, INTENT(OUT) :: VIEW_PTR(${ft.viewShape}$)
  ${ft.type}$, INTENT(IN), POINTER :: DATA(${ft.shape}$)
  INTEGER(KIND=JPIM), INTENT(IN) :: IDX
  LOGICAL, INTENT(IN) :: CONTIG_FIELDS

  INTEGER(KIND=JPIM) :: LBOUNDS(${ft.rank}$)

  LBOUNDS=LBOUND(DATA)
  IF(CONTIG_FIELDS)THEN
    VIEW_PTR(${','.join('LBOUNDS(%d):'%(r+1) for r in range(ft.viewRank))}$) => DATA(${','.join(':' for _ in range(ft.viewRank-1))}$,IDX,:)
  ELSE
    VIEW_PTR(${','.join('LBOUNDS(%d):'%(r+1) for r in range(ft.viewRank))}$) => DATA(${','.join(':' for _ in range(ft.viewRank))}$,IDX)
  ENDIF

END SUBROUTINE ${ftn}$_GET_VIEW

SUBROUTINE ${ftn}$_SET_CHILDREN_STATUS(CHILDREN, ISTATUS)
   TYPE(${f'FIELD_{ft.rank-1}{ft.suffix}'}$_PTR), INTENT(INOUT):: CHILDREN(:)
   INTEGER(KIND=JPIM), INTENT(IN) :: ISTATUS
   INTEGER(KIND=JPIM) :: I

   DO I=1,SIZE(CHILDREN)
      CHILDREN(I)%PTR%ISTATUS = ISTATUS
   ENDDO

END SUBROUTINE ${ftn}$_SET_CHILDREN_STATUS

SUBROUTINE ${ftn}$_CHECK_CHILDREN_STATUS(CHILDREN, ISTATUS, STAT)
   TYPE(${f'FIELD_{ft.rank-1}{ft.suffix}'}$_PTR), INTENT(INOUT):: CHILDREN(:)
   INTEGER(KIND=JPIM), INTENT(IN) :: ISTATUS
   LOGICAL, INTENT(OUT) :: STAT
   INTEGER(KIND=JPIM) :: I

   STAT = .TRUE.
   DO I=1,SIZE(CHILDREN)
      IF(CHILDREN(I)%PTR%ISTATUS /= ISTATUS) STAT = .FALSE.
   ENDDO

END SUBROUTINE ${ftn}$_CHECK_CHILDREN_STATUS

#:for buffer_type in ['OWNER', 'WRAPPER']
FUNCTION ${ftn}$_${buffer_type}$_GET_VIEW(SELF, BLOCK_INDEX, ZERO) RESULT(VIEW_PTR)
  CLASS(${ftn}$_${buffer_type}$) :: SELF
  ${ft.type}$, POINTER :: VIEW_PTR(${ft.viewShape}$)
  INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
  LOGICAL, OPTIONAL,  INTENT(IN) :: ZERO

  INTEGER(KIND=JPIM) :: IDX

  IDX = BLOCK_INDEX
  IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD ()

  CALL ${ftn}$_GET_VIEW(VIEW_PTR, IDX, SELF%PTR, SELF%CONTIG_FIELDS)

  IF (PRESENT(ZERO)) THEN
    IF (ZERO) VIEW_PTR(${ft.viewShape}$) = ${ft.default}$
  END IF

! Mark data dirty on the device: the pointer returned by GET_VIEW may be rw
  IF (IAND (SELF%ISTATUS, NDEVFRESH) == NDEVFRESH) THEN
    SELF%ISTATUS = IAND(SELF%ISTATUS, NOT(NDEVFRESH))
  ENDIF

  CALL ${ftn}$_SET_CHILDREN_STATUS(SELF%CHILDREN, SELF%ISTATUS)
END FUNCTION ${ftn}$_${buffer_type}$_GET_VIEW

#:for mode in ['RDONLY', 'RDWR']
SUBROUTINE ${ftn}$_${buffer_type}$_GET_DEVICE_DATA_${mode}$(SELF, PPTR, QUEUE)
  CLASS(${ftn}$_${buffer_type}$),                INTENT(INOUT) :: SELF
  ${ft.type}$, POINTER,          INTENT(INOUT) :: PPTR(${ft.shape}$)
  INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

  LOGICAL :: STAT
  INTEGER(KIND=JPIM) :: IFIELD
  INTEGER(KIND=JPIM) :: LBOUNDS(${ft.rank}$)

  CALL ${ftn}$_CHECK_CHILDREN_STATUS(SELF%CHILDREN, SELF%ISTATUS, STAT)

  IF(STAT)THEN
    CALL SELF%${ft.name}$_GET_DEVICE_DATA_${mode}$(PPTR, QUEUE=QUEUE)

    DO IFIELD=1,SELF%NUM_CHILDREN
       SELF%CHILDREN(IFIELD)%PTR%ISTATUS = SELF%ISTATUS
    ENDDO

    IF(SELF%CONTIG_FIELDS)THEN
       #:set ar = (',').join([':' for _ in range(0, ft.rank-1)])
       DO IFIELD=1,SELF%NUM_CHILDREN
          SELF%CHILDREN(IFIELD)%PTR%DEVPTR => SELF%DEVPTR(${ar}$,IFIELD)
       ENDDO
    ELSE
       #:set ar = (',').join([':' for _ in range(0, ft.rank-2)])
       DO IFIELD=1,SELF%NUM_CHILDREN
          SELF%CHILDREN(IFIELD)%PTR%DEVPTR => SELF%DEVPTR(${ar}$,IFIELD,:)
       ENDDO
    ENDIF
  ELSE
    DO IFIELD=1,SELF%NUM_CHILDREN
       CALL SELF%CHILDREN(IFIELD)%PTR%${f'FIELD_{ft.rank-1}{ft.suffix}'}$_SYNC_DEVICE_${mode}$(QUEUE=QUEUE)
    ENDDO

    SELF%ISTATUS = SELF%CHILDREN(1)%PTR%ISTATUS

    IF(SELF%CONTIG_FIELDS)THEN
       #:set ar = (',').join([':' for _ in range(0, ft.rank-1)])
       DO IFIELD=1,SELF%NUM_CHILDREN
          SELF%DEVPTR(${ar}$,IFIELD) = SELF%CHILDREN(IFIELD)%PTR%DEVPTR
       ENDDO
    ELSE
       #:set ar = (',').join([':' for _ in range(0, ft.rank-2)])
       DO IFIELD=1,SELF%NUM_CHILDREN
          SELF%DEVPTR(${ar}$,IFIELD,:) = SELF%CHILDREN(IFIELD)%PTR%DEVPTR
       ENDDO
    ENDIF

    LBOUNDS=LBOUND(SELF%PTR)
    PPTR (${ft.lbptr}$) => SELF%DEVPTR (${','.join(':' for _ in range(ft.rank))}$)
  ENDIF
END SUBROUTINE ${ftn}$_${buffer_type}$_GET_DEVICE_DATA_${mode}$

#:endfor
#:endfor

#:endfor


END MODULE FIELD_${RANK}$${SUFF}$_BUFFER_MODULE
